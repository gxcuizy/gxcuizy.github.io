<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3自动生成MySQL数据字典的markdown文本]]></title>
    <url>%2F2020%2F05%2F06%2FPython3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90MySQL%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E7%9A%84markdown%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[为啥要写这个脚本五一前的准备下班的时候，看到同事为了做数据库的某个表的数据字典，在做一个复杂的人工操作，就是一个字段一个字段的纯手撸，那速度可想而知是多么的折磨和锻炼人的意志和耐心，反正就是很耗时又费力的活，关键是工作效率太低了，于是就网上查了一下，能否有在线工具可用，但是并没有找到理想和如意的，于是吧，就干脆自己撸一个，一劳永逸，说干就干的那种…… 先屡一下脚本思路第一步：输入或修改数据库连接配置信息，以及输入数据表名 第二步：利用pymysql模块连接数据库，并判断数据表是否存在 第三步：获取数据表的注释 第四步：存储文件夹和文件处理，删除已存在的文件避免重复写入 第五步：先写入Markdown的表头部信息 第六步：从information_schema中查询表结构和相关信息 第七步：依次拼装每个字段的Markdown文本写入，结束并关闭相关连接 运行环境Python运行环境：Windows + python3.6用到的模块：pymysql、os、time、pyinstaller如未安装的模块，请使用pip instatll xxxxxx进行安装，例如：pip install pyinstaller 获取数据库连接信息的两种方式既然是要做数据字典，那么肯定就需要先连接数据库，而连接数据库，自然就需要先知道数据库的基本信息：IP地址、用户名、登录密码、数据库名等…… 为了方便，我这里写了两种配置MySQL连接的方法：第一种是直接配置在代码里，直接修改代码里的连接信息就可以了；另外一种就是通过手动输入链接信息，不用修改代码，方便快速多用。具体的完整源码，我都上传到同性交友网站GitHub了，可以点下面的链接查看…… 修改代码的完整源码：data_dict_config.py 手动输入的完整源码：data_dict_input.py 执行效果图执行data_dict_config.py脚本的时候，交互效果如下 执行data_dict_input.py脚本的时候，交互效果如下 执行完脚本后，会在当前目录下，生成一个mysql_dict文件夹，打开文件夹，里面的.md格式的文件就是每个表的markdown文本的表格写法，拷贝里面的文本到任何支持mardkwon地方就可以使用和查看，例如我放到有道云笔记上，部分效果如下 生成可执行文件为了方便不同的人群方便快速的使用，可以不用安装Python环境来执行py脚本文件，我把相关脚本打包成Windows可直接执行的exe文件，下载双击运行即可（可能有的系统需要管理员权限运行），打包的方式很简单，就是利用pyinstaller模块进行快速打包，省时省力，具体更多用法大家可以网上查一下。 打包命令为：pyinstaller -F -i favicon.ico data_dict_input.py 执行这个命令后，就会在当前目录下生成一个dict和其他的文件夹和相关文件，其中，打开dict，下面会生成一个文件名相同的exe文件data_dict_input.exe，双击这个文件就可以打开了，拷贝到其他地方一样可以使用。 下面我把两种方式的脚本，都生成了exe可执行文件，大家可以直接点击下载试用，如果下载不了，请直接去GitHub仓库下载或者自己生成 修改代码的可执行文件：data_dict_config.exe 手动输入的可执行文件：data_dict_input.exe 完整代码为了方便部分人想偷懒，不直接去交友网站查看，我在这里也贴一下其中的一个源码出来吧（其实吧，我是觉得文章篇幅有点短，来凑字数的，大家明白就好，看透不说透）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#!/usr/bin/env python# -*- coding: utf-8 -*-"""自动生成MySQL数据表的数据字典支持多个自动获取数据库连接信息，方便多用author: gxcuizydate: 2020-04-30"""import pymysqlimport osimport timeclass DataDict(object): def __init__(self, connect_info): # 数据库连接配置 self.host_name = connect_info[0] self.user_name = connect_info[1] self.pwd = connect_info[2] self.db_name = connect_info[3] self.folder_name = 'mysql_dict' def run(self, table_str): """脚本执行入口""" try: # 创建一个连接 conn = pymysql.connect(self.host_name, self.user_name, self.pwd, self.db_name) # 用cursor()创建一个游标对象 cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) except Exception: print('数据库连接失败，请检查连接信息！') exit(1) table_list = table_str.split(',') for table_name in table_list: # 判断表是否存在 sql = "SHOW TABLES LIKE '%s'" % (table_name,) cursor.execute(sql) result_count = cursor.rowcount if result_count == 0: print('%s数据库中%s表名不存在，无法生成……' % (self.db_name, table_name)) continue # 表注释获取 print('开始生成表%s的数据字典' % (table_name,)) sql = "show table status WHERE Name = '%s'" % (table_name,) cursor.execute(sql) result = cursor.fetchone() table_comment = result['Comment'] # 文件夹和文件处理 file_path = self.folder_name + os.sep + table_name + '.md' self.deal_file(file_path) # 打开文件，准备写入 dict_file = open(file_path, 'a', encoding='UTF-8') dict_file.write('#### %s %s' % (table_name, table_comment)) dict_file.write('\n | 字段名称 | 字段类型 | 默认值 | 字段注释 |') dict_file.write('\n | --- | --- | --- | --- |') # 表结构查询 field_str = "COLUMN_NAME,COLUMN_TYPE,COLUMN_DEFAULT,COLUMN_COMMENT" sql = "select %s from information_schema.COLUMNS where table_schema='%s' and table_name='%s'" % (field_str, self.db_name, table_name) cursor.execute(sql) fields = cursor.fetchall() for field in fields: column_name = field['COLUMN_NAME'] column_type = field['COLUMN_TYPE'] column_default = str(field['COLUMN_DEFAULT']) column_comment = field['COLUMN_COMMENT'] info = ' | ' + column_name + ' | ' + column_type + ' | ' + column_default + ' | ' + column_comment + ' | ' dict_file.write('\n ' + info) # 关闭连接 print('完成表%s的数据字典' % (table_name,)) dict_file.close() cursor.close() conn.close() def deal_file(self, file_name): """处理存储文件夹和文件""" # 不存在则创建文件夹 if not os.path.exists(self.folder_name): os.mkdir(self.folder_name) # 删除已存在的文件 if os.path.isfile(file_name): os.unlink(file_name) def test_conn(self, conn_info): """测试数据库连接""" try: # 创建一个连接 pymysql.connect(conn_info[0], conn_info[1], conn_info[2], conn_info[3]) return True except Exception: return False# 程序执行入口if __name__ == '__main__': # 数据数据连接信息 conn_info = input('请输入mysql数据库连接信息(格式为：主机IP,用户名,登录密码,数据库名)，逗号分隔且输入顺序不能乱，例如：192.168.0.1,root,root,test_db：') conn_list = conn_info.split(',') while conn_info == '' or len(conn_list) != 4: conn_info = input('请正确输入mysql数据库连接信息(格式为：主机IP,用户名,登录密码,数据库名)，逗号分隔且输入顺序不能乱，例如：192.168.0.1,root,root,test_db：') conn_list = conn_info.split(',') # 测试数据库连接问题 dd_test = DataDict(conn_list) db_conn = dd_test.test_conn(conn_list) while db_conn == False: conn_info = input('请正确输入mysql数据库连接信息(格式为：主机IP,用户名,登录密码,数据库名)，逗号分隔且输入顺序不能乱，例如：192.168.0.1,root,root,test_db：') conn_list = conn_info.split(',') if len(conn_list) != 4: continue dd_test = DataDict(conn_list) db_conn = dd_test.test_conn(conn_list) # 输入数据表名称 table_s = input('请输入数据库表名(例如：t_order)，如需输入多个表名请用英文逗号分隔(例如：t_order,t_goods)，结束使用请输入q：') dd = DataDict(conn_list) while table_s != 'q': dd.run(table_s) table_s = input('继续使用请输入数据库表名（例如t_order），如需输入多个表名请用英文逗号分隔（例如t_order,t_goods），结束使用请输入q）：') else: print('谢谢使用，再见……') time.sleep(1) 最后老规矩，大家有任何问题，都可以留言或者各种渠道告诉我，虽然我可能也不会去修改。方法和思路万千，如果你有其他思路以及想法的，欢迎留言分享和交流……]]></content>
      <tags>
        <tag>markdown</tag>
        <tag>MySQL</tag>
        <tag>工具</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【惊呆了】深圳某程序员竟敢公众场合高端黑舍友，就不怕有生命危险吗？]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%B7%B1%E5%9C%B3%E6%9F%90%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AB%9F%E6%95%A2%E5%85%AC%E4%BC%97%E5%9C%BA%E5%90%88%E9%AB%98%E7%AB%AF%E9%BB%91%E8%88%8D%E5%8F%8B%EF%BC%8C%E5%B0%B1%E4%B8%8D%E6%80%95%E6%9C%89%E7%94%9F%E5%91%BD%E5%8D%B1%E9%99%A9%E5%90%97%2F</url>
    <content type="text"><![CDATA[前言最近连着输出了几篇技术文，是时候换个菜了，来点猛料，来点不一样的，荤素搭配。这篇写生活，写人，写事，更写实；主要关于一个靓仔肥的事情，他的名字叫做Harden，关于名字，有人可能会问我，能说真名吗？肯定直接不能说真名的，这种思想实在是太危险，别问为啥，往下看就行了…… 温馨提醒：本篇文章，少儿和妇女不宜继续往下继续阅读，此类人群请自觉点击右上角的X关闭页面 初识Harden曾经那个少年说句实话，一时间，我也记不起来是什么时候开始认识的Harden，应该是大二后半段认识的吧，大一的时候，虽然同在一栋楼，我们专业主要在二楼，Harden他们专业宿舍在三楼，但是由于并不是同一专业，所以并没有太多的交集，所以不认识也正常，先给大家看一下那个时候的帅气小伙吧，应该是大一的时候照的。 至于怎么认识的Harden，我想应该是另外一个人，这个人名字我们就叫做大表锅，大二的时候，我和大表锅都是班长，所以慢慢的玩的挺好，然后应该是大表锅拉上的Harden，一来二往，就认识了Harden，肯定就是这样的。 花甲螺事件 看了图，你就明白了吧，没错，你没看错，这就是在医院躺着的Harden，至于为啥趟医院呢，这得从一顿饭说起，炎炎夏日的一个晚上，我和大表锅还是Harden三人一起在外面吃夜宵还是吃晚饭来着忘记了，这不重要，重要的是一道菜，这个菜的中国的一道传统海鲜，叫做爆炒花甲，Harden吃完回去后，就浑身难受，结果就进了医院；第二天，Harden舍友还买了一提香蕉去医院看望了他，糟蹋了钱又浪费了香蕉（这件事，我是后面好久才知道的……）。 校园趣事社团的那些事 Harden的这些事，我本来也不想说的，但是也要黑一下，我就问你们，摸着你们的良心说：当年你们进入社团的主要目的和动机是什么？是为了向师兄师姐学东西吗？是为了向其他专业的人学习本专业外的课程吗？是为了学习与不同的人群相处和学习做人做事的方法吗？可能有的人确实是这种想法，但是Harden进入社团的目的是非常单纯的，那就是有更多的机会撩妹；我后面听Harden的舍友说，大一的生活，Harden拖着他们宿舍的几个人和他一起去加入女生部，比如拖上了大表锅和国企等，但是国企好像没去，最后Harden和大表锅两人也顺利了加入了女生部，但是进入后发现：理想是丰满的，但是现实是很残酷。怎么说说呢，因为进入后，发现女生部男生很多，哈哈哈哈哈哈，笑死我……因为进入女生部的怀揣着追求和理想加入的（女生多方便撩妹，有更多机会接触女生，也有可能去女生宿舍串门检查，想想都挺激动睡不着觉了……），好了，黑到为止。 甜蜜生活 不用我说了吧，看图就明白的事，隔着马赛克，都能感觉到Harden看小女生的小眼神是多么的……（看透不说透，看家都懂就行，说透了容易被抓到证据，太危险）；对了，再说明一下，这个小女生并不是Harden校园时候的小女友，只是没其他图，拿这个凑合着用一下，大家明白Harden的校园生活还是挺滋润就行，这种小日子尔等羡慕不来的，真是个重色轻友的家伙…… 韭菜鸡蛋事件 韭菜炒鸡蛋，这个菜大家应该都不陌生吧，都有吃过的吧？至于功效嘛，大家也都懂的，反正大补就对了，好了，废话少说，进入正题。有一次，Harden和宿舍几个人去广西柳州游玩，在一次吃饭的时候，点了其中的一个菜，就是韭菜鸡蛋，上菜后，Harden的眼睛，全在这个菜上，然后故意问其他人：“你们吃点韭菜鸡蛋”。但是其他人一看Harden的眼神，凶神恶煞一般的看着，完全没有一个人敢吃，只能全部拒绝道：“吃饱了，不吃了”。然后Harden就兴奋了，心想：“完美，全都是我的了”。然后Harden一口就把一道刚端上桌的韭菜鸡蛋给吃没了，简直不可思议…… 变形记 同样的，先看图，再说事，这是大三的生活，左边是大表锅，中间是Harden，右边是国企（拿过国企单位的MVP的人），可以很明显的看出Harden的饭量和魁梧的身材，和前面的帅小伙相比，完全已经开始偏离正常发育的轨迹了（越长越肥，越长越丑，越长越坑，越长越逗比……，停！不能继续黑了，有危险）。 上图是Harden和他“安徽老家的媳妇”，别羡慕，这种事是你们羡慕不来的。没认识Harden之前，听他舍友说，每次其他舍友去食堂打完饭，都会先给Harden碗里一点，我也不知道这是个什么规矩，反正，其他人都这么干，慢慢的大家也就不觉得奇怪了，反而养成了这种习惯，每次吃饭的时候，Harden的碗里都是满满的一碗，甚至都盛不下了，但是Harden不是那种会浪费粮食的人，给多少就吃多少（黑一下：有的时候，食堂阿姨给舍友打的饭菜少了点，舍友不想给Harden了，但是Harden的一个小眼神过来，舍友就慌了，就算自己饿肚子也要把自己的饭菜给Harden的碗里装满，同情Harden的舍友几秒钟）。但是，吃饭一时爽，肥肉也跟着来了，当年一百二十斤不到的帅小伙，已经长成了一百四五十斤的肥崽子，成功变形。 三天不吃饭 没错，Harden已经成功从一个靓仔变成了一个肥仔，所以后面如果说肥仔也是Harden；听后面Harden的舍友说，有一次大表锅他们和Harden打赌什么来着，说Harden如果输了，就三天不吃饭，结果不出意外，Harden顺利输了，结果Harden真的三天不吃饭，天天吃粉啥的，真的坚持了三天不吃饭，给肥仔点赞，给Harden打call。这个事，我本来不想黑的，为后面继续黑做铺垫，随口提一下，希望不要有生命危险…… 毕业后多才多艺的Harden在学校的生活，可能是接触的没有那么多，并没有发现Harden竟然是如此的多才多艺，毕竟，在学校的生活，Harden的主要时间就是陪小女友，玩游戏，吃饭睡觉，并没有太多时间再去表现自己的才艺技能，真是埋没的太久了，下面详细黑，如有黑不到的，大家自由发挥了…… 武功盖世（扬言要打哭泰森） 看这个拳法的招式，大家应该都猜到是什么拳了吧？没错，就是Harden式肥螳螂拳，从这拳法的套路，还有最后一式，又有点像鹰拳，我又看不太懂，也不敢说什么，反正黑就完事了！除了肥螳螂拳，还会憋气神功，一法功，整栋楼都在震动的感觉，而且时不时法功，还有想什么时候法功就什么时候法功，无敌模式开启，反正我们平民百姓，是不敢说什么的，只能默默忍受；看过天龙八部的都应该知道，段誉的独门武功是什么吧？那就是凌波微步，Harden也是练得出神入化呀，虽然比不了段誉的速度，但持久度绝对不在段誉之下。当然了，除了提到的这些招式，Harden还会其他很多拳法，就不一一黑了…… 会唱歌（遗落民间的中国好声音） 对于歌唱强者来说，什么声音都是伴奏，什么物品都是麦克风，什么环境都能即兴一展歌喉，没有你不想听的歌，只有我不想唱的曲；Harden的成名作《我的祖国》，日常没有一丝丝改变的那个《少年》，洗澡后《最靓的崽》；当然了，Harden不仅是一位歌唱家，更是一名作曲家，比如最经典的原创歌曲MV《我的袜子》，就是自己编曲，自己出演，自己演唱！ 会跳舞（未来舞王可期） 看这曼妙的舞姿，是多么的专业，多么的勾人心魄……不行，不能昧着良心说假话了，得正儿八经的黑了。不管是跳舞还是唱歌，都自顾自己嗨，Harden虽然唱歌好听但是要命啊，Harden虽然跳舞销魂但是没眼看呀，完全不给我们一条活路，太难了，我等生存环境堪忧啊！ 会转圈圈（能停下来算我输） 找不到巡逻转圈圈的资源，给大家看一个Harden更高难度的360度连环全身翻滚。会唱歌，会跳舞，那转圈圈肯定不在话下了，Harden转起圈圈来，简直开挂一般，完全停不下来，如果你过去叫停，可能会有生命危险的那种，劝君莫冲动，好好活着不好吗？不知道世界吉尼斯纪录有没有这项转圈圈的，如果有，只要Harden愿意去尝试，我相信Harden一定是这个记录的保持者，并且无人能超越，这就是强者的寂寞，一般人领会不到的。 会喷人（都是别人坑我，一帮小学生放假了） “论玩游戏，我Harden没坑过谁，都是别人坑我的，mmp”。Harden总是这样说，但是战绩和评分是不会骗人的，上面的动图也能模糊的看到，全队死了6次，Harden一个人就送了4个人头，真想说一句：“肥啊，别送，包赢！”。0-4-0也就算了，老老实实Carry吧，但是呢，Harden却一直在说队友这里坑，那里坑的，泉水指挥官也不浪费时间；Harden属于那种玩啥都菜，玩啥都黑铁水平都不到的人，但是呢，王者的架势必须有：你们都是小学生，坑的一笔，我要举报你们送人头，拉黑再也不和你们玩了，但是一看评分和战绩，Harden评分最低。作为旁人的我等，也不敢多说什么呀，害怕有生命危险，活着真不容易…… 会捅人（不需要任何理由） 前面，我也有提到过，我等一直生活在Harden的威胁和肥肉之下，动不动就说要捅我们的话啥的，就像上面的截图一样，完全看Harden的心情来的，心情好要捅人，心情不好也要捅人，完全不需要任何理由，因为Harden说：我肥我说了算！真是没天理了，王法何在？自由何在？平等何在？安全何在？只要有Harden的地方，我们总是在方方面面被压迫和欺负的对象，我们至今还能活着已经算是个奇迹了，由衷的感恩：感恩Harden的不捅之恩和平日里的施舍，让我们能得以活到现在，真是太难了！ 结束 最后来一张Harden钓鱼的生活照（特殊疫情期间，大家外出还是要把口罩戴好），本来还想继续黑的，但是呢，想给自己留条后路，因为黑人留一线，日后不被捅。好了，这次就先黑到这，我得回去收拾行李跑路了，因为回去的话，肯定又要被Harden追着捅了，所以三十六计走为上，祝我好运吧！ 不，做人不能怂；黑人更是不能怂，我还就不跑了，最后再来一张视频截取的GIF动图（本来想放个完整视频的，因为视频看起来更加魔性，但是放不了，没办法，有想法看原版完整视频的，可以私聊我哦，哈哈哈哈……），话不多说，直接上图，因为发完，我真的得跑路了，晚点就来不及了……]]></content>
      <tags>
        <tag>程序员</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析ThinkPHP5框架从入口到输出界面的加载流程]]></title>
    <url>%2F2020%2F04%2F21%2F%E5%88%86%E6%9E%90ThinkPHP5%E6%A1%86%E6%9E%B6%E4%BB%8E%E5%85%A5%E5%8F%A3%E5%88%B0%E8%BE%93%E5%87%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装ThinkPHP怎么安装，我就不细说了，官方文档-安装ThinkPHP说的很全了，可以通过Composer、Git或者直接去ThinkPHP官网下载zip包，我安装的版本是5.0.24 测试运行下载安装完毕后，如果项目是下载目录是你本地服务器的项目根目录下，可以直接在浏览器输入地址http://localhost/thinkphp5/public/，就可以进入到ThinkPHP5的默认欢迎页，如下图所示，这就说明ThinkPHP5已经安装成功 除了上面的这个方式的地址运行，我们也可以通过Apache或者Nginx配置虚拟主机实现项目的访问，有兴趣的可以网上查看具体教程，然后配置虚拟主机进行访问。 下面进入正题，我们来逐步分析ThinkPHP5的执行流程…… 入口文件（public\index.php）打开public\index.php文件后，我们可以看到，入口文件原始代码如下 123456// [ 应用入口文件 ]// 定义应用目录define('APP_PATH', __DIR__ . '/../application/');// 加载框架引导文件require __DIR__ . '/../thinkphp/start.php'; 入口文件代码很简洁，就两行代码，作用分别为 define(&#39;APP_PATH&#39;, __DIR__ . &#39;/../application/&#39;);定义应用目录的常量APP_PATH require __DIR__ . &#39;/../thinkphp/start.php&#39;;加载框架引导文件 除了上面的这两个作用外，我们还可以额外在入口文件中，定义我们自己的常量，例如添加一行代码define(&#39;PUBLIC_PATH&#39;, __DIR__ .&#39;/../public&#39;);定义public目录的常量以及一些预处理等 加载框架引导文件（thinkphp\start.php）同样的，进入thinkphp\start.php文件后，我们可以知道，代码并不多 12345678namespace think;// ThinkPHP 引导文件// 1. 加载基础文件require __DIR__ . '/base.php';// 2. 执行应用App::run()-&gt;send(); 从这简短的两行代码，我们可以看到，主要左右有两个 require __DIR__ . &#39;/base.php&#39;;加载基础文件 App::run()-&gt;send();执行应用 下面两个大点，将具体介绍这两个左右都做了什么 加载基础文件（thinkphp\base.php）我们继续打开thinkphp\base.php文件，发现这个文件终于不再像前两个文件那样，只有两行代码了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354define('THINK_VERSION', '5.0.24');define('THINK_START_TIME', microtime(true));define('THINK_START_MEM', memory_get_usage());define('EXT', '.php');define('DS', DIRECTORY_SEPARATOR);defined('THINK_PATH') or define('THINK_PATH', __DIR__ . DS);define('LIB_PATH', THINK_PATH . 'library' . DS);define('CORE_PATH', LIB_PATH . 'think' . DS);define('TRAIT_PATH', LIB_PATH . 'traits' . DS);defined('APP_PATH') or define('APP_PATH', dirname($_SERVER['SCRIPT_FILENAME']) . DS);defined('ROOT_PATH') or define('ROOT_PATH', dirname(realpath(APP_PATH)) . DS);defined('EXTEND_PATH') or define('EXTEND_PATH', ROOT_PATH . 'extend' . DS);defined('VENDOR_PATH') or define('VENDOR_PATH', ROOT_PATH . 'vendor' . DS);defined('RUNTIME_PATH') or define('RUNTIME_PATH', ROOT_PATH . 'runtime' . DS);defined('LOG_PATH') or define('LOG_PATH', RUNTIME_PATH . 'log' . DS);defined('CACHE_PATH') or define('CACHE_PATH', RUNTIME_PATH . 'cache' . DS);defined('TEMP_PATH') or define('TEMP_PATH', RUNTIME_PATH . 'temp' . DS);defined('CONF_PATH') or define('CONF_PATH', APP_PATH); // 配置文件目录defined('CONF_EXT') or define('CONF_EXT', EXT); // 配置文件后缀defined('ENV_PREFIX') or define('ENV_PREFIX', 'PHP_'); // 环境变量的配置前缀// 环境常量define('IS_CLI', PHP_SAPI == 'cli' ? true : false);define('IS_WIN', strpos(PHP_OS, 'WIN') !== false);// 载入Loader类require CORE_PATH . 'Loader.php';// 加载环境变量配置文件if (is_file(ROOT_PATH . '.env')) &#123; $env = parse_ini_file(ROOT_PATH . '.env', true); foreach ($env as $key =&gt; $val) &#123; $name = ENV_PREFIX . strtoupper($key); if (is_array($val)) &#123; foreach ($val as $k =&gt; $v) &#123; $item = $name . '_' . strtoupper($k); putenv("$item=$v"); &#125; &#125; else &#123; putenv("$name=$val"); &#125; &#125;&#125;// 注册自动加载\think\Loader::register();// 注册错误和异常处理机制\think\Error::register();// 加载惯例配置文件\think\Config::set(include THINK_PATH . 'convention' . EXT); 仔细一看，发现代码虽然有六十多行，但是，代码的作用却显而易见，作用主要有以下六点 使用define(&#39;&#39;, &#39;&#39;)函数定义了很多个系统常量，外加两个环境常量 引入loader类（thinkphp\library\think\loader.php），供后续使用 加载环境变量配置文件（环境变量配置文件名为.env，这个文件不一定存在，都是在实际开发过程中根据需要加上去的） 调用\think\Loader::register()注册自动加载机制 注册系统自动加载 Composer自动加载支持 注册命名空间定义 加载类库映射文件，存在于runtime缓存目录下classmap.php 自动加载extend目录 调用\think\Error::register()注册异常和错误处理机制 加载惯例配置文件（thinkphp\convention.php） 执行应用（thinkphp\library\think\App.php）下的run方法为了方便，这个run方法的代码虽然有点长，但是我还是选择把整个方法贴出来，别打我哈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 执行应用程序 * @access public * @param Request $request 请求对象 * @return Response * @throws Exception */public static function run(Request $request = null)&#123; $request = is_null($request) ? Request::instance() : $request; try &#123; $config = self::initCommon(); // 模块/控制器绑定 if (defined('BIND_MODULE')) &#123; BIND_MODULE &amp;&amp; Route::bind(BIND_MODULE); &#125; elseif ($config['auto_bind_module']) &#123; // 入口自动绑定 $name = pathinfo($request-&gt;baseFile(), PATHINFO_FILENAME); if ($name &amp;&amp; 'index' != $name &amp;&amp; is_dir(APP_PATH . $name)) &#123; Route::bind($name); &#125; &#125; $request-&gt;filter($config['default_filter']); // 默认语言 Lang::range($config['default_lang']); // 开启多语言机制 检测当前语言 $config['lang_switch_on'] &amp;&amp; Lang::detect(); $request-&gt;langset(Lang::range()); // 加载系统语言包 Lang::load([ THINK_PATH . 'lang' . DS . $request-&gt;langset() . EXT, APP_PATH . 'lang' . DS . $request-&gt;langset() . EXT, ]); // 监听 app_dispatch Hook::listen('app_dispatch', self::$dispatch); // 获取应用调度信息 $dispatch = self::$dispatch; // 未设置调度信息则进行 URL 路由检测 if (empty($dispatch)) &#123; $dispatch = self::routeCheck($request, $config); &#125; // 记录当前调度信息 $request-&gt;dispatch($dispatch); // 记录路由和请求信息 if (self::$debug) &#123; Log::record('[ ROUTE ] ' . var_export($dispatch, true), 'info'); Log::record('[ HEADER ] ' . var_export($request-&gt;header(), true), 'info'); Log::record('[ PARAM ] ' . var_export($request-&gt;param(), true), 'info'); &#125; // 监听 app_begin Hook::listen('app_begin', $dispatch); // 请求缓存检查 $request-&gt;cache( $config['request_cache'], $config['request_cache_expire'], $config['request_cache_except'] ); $data = self::exec($dispatch, $config); &#125; catch (HttpResponseException $exception) &#123; $data = $exception-&gt;getResponse(); &#125; // 清空类的实例化 Loader::clearInstance(); // 输出数据到客户端 if ($data instanceof Response) &#123; $response = $data; &#125; elseif (!is_null($data)) &#123; // 默认自动识别响应输出类型 $type = $request-&gt;isAjax() ? Config::get('default_ajax_return') : Config::get('default_return_type'); $response = Response::create($data, $type); &#125; else &#123; $response = Response::create(); &#125; // 监听 app_end Hook::listen('app_end', $response); return $response;&#125; 这大概90行的代码，具体做了什么呢，结合注释分析，主要有以下几步的功能 第一步：处理变量$request，保证有效有用不为null 第二步：self::initCommon()调用当前控制器中的initCommon()方法，负责初始化应用，并返回配置信息 Loader::addNamespace(self::$namespace, APP_PATH);注册命名空间 self::init()调用本类的init()方法初始化应用 加载各种配置文件 加载行为扩展文件 加载公共文件 加载语言包 应用调试模式相关处理 加载额外文件，通过配置项extra_file_list的值去加载相关文件 date_default_timezone_set($config[&#39;default_timezone&#39;]);设置系统时区 调用Hook::listen(&#39;app_init&#39;);监听app_init标签的行为 第三步：判断是否进行模块或者控制器的绑定 第四步：系统语言设置和加载 第五步：self::routeCheck($request, $config)加载当前控制器的routeCheck()方法进行路由检测 先进行路由地址配置检测，先读取缓存路由，不存在再导入路由文件配置 无路由配置，直接解析模块/控制器/操作 返回module模块信息（模块名、控制器名和操作方法名） 第六步：开启调试模式下，记录路由和请求信息的日志 第七步：self::exec($dispatch, $config)调用控制器中的exec()方法执行调用分发 根据用户请求类型进行分发处理，这里是module模块类型 调用self::module()执行模块，进行模块部署和初始化，获取和设置当前控制器名和操作名 第八步：清空类的实例化，并输出相应格式的数据到客户端，即用户看到的输出界面 总结本文大概解析了ThinkPHP5的基础执行流程，有说的不到位的，也不用给我说了，因为我也不会补上去的，就是这么皮；但是如果是说错的呢，麻烦指出来，我肯定会加以改正的，就这么耿直。对了，如果觉得对你有帮助，点个赞再走呗，感谢！]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统初探MongoDB的基础使用]]></title>
    <url>%2F2020%2F04%2F14%2FWindows%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2MongoDB%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MongoDB是什么？ MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 下载安装MongoDB 提供了可用于 32 位和 64 位系统的预编译二进制包，你可以从MongoDB官网下载安装，MongoDB 预编译二进制包下载地址：https://www.mongodb.com/download-center/community 我的MongoDB是安装在D:\mongodb目录下，安装好后，进入到安装目录D:\mongodb\data下，新建一个数据库目录，例如db mongodb服务端启动绝对路劲的方式启动打开命令行工具，这里我推荐一下Cmder命令行工具，我一直在用，打开后，输入D:\mongodb\bin\mongod --dbpath D:\mongodb\data\db回车执行 mongod命令的方式启动配置了bin目录的Path路径，可以直接用mongod命令启动服务器，执行mongod --dbpath D:\mongodb\data\db或者在data目录下执行mongod --dbpath .\db 配置bin的Path路径为了启动mongodb方便，将mongod.exe路径加入环境变量，位置：计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量,在系统变量的Path里，在末尾加上安装MongoDB的bin目录，记得加英文分号‘;’。全部确定保存后，重新打开命令行窗口，就可以在任何地方都能用到mongod命令以及bin目录下的其他命令了 客户端连接在之前启动了服务器后，千万不要关闭服务端的命令行窗口，需要再重新打开一个命令行窗口，在任意目录下输入mongo即可启动客户端（如果遇到“’mongo’不是内部或外部命令，也不是可运行的程序或批处理文件。”，请配置上面的Path路径）；如果你就是不想配置Path路径，那你直接到你安装目录的bin目录下，双击mongo.exe打开也能直接连接客户端 MongoDB 概念解析在mongodb中基本的概念是文档、集合、数据库 数据库：一个mongodb中可以建立多个数据库；MongoDB的默认数据库为”db”，该数据库存储在data目录中。使用show dbs，可以查看全部数据库 集合：集合就是 MongoDB 文档组，类似于RDBMS中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据。使用show collections，可以查看当前数据库实例下的全部集合 文档：文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型。使用db.collection.find()命令，可以查看collection集合下的全部文档 数据库（db）初次连接客户端，使用db查看，默认使用的是test数据库，再使用show dbs查看全部数据库，并使用use命令切换数据库，例如使用use admin切换到admin数据库12345678910&gt; dbtest&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBschool 0.000GBtest 0.000GB&gt; use adminswitched to db admin 新建数据库新建数据库的语法为：use databaseName，也就是和切换数据库是一样的，如果切换的数据库不存在，则创建新的数据库，例如需要使用use order新建一个数据库order，但是使用show dbs查看并没有发现新建的数据库，也就是空集合的数据库不会显示出来，则需要向order中随便插入一个文档就能看到了，例如我们执行db.info.insert({&#39;name&#39;:&#39;张三&#39;,&#39;note&#39;:&#39;hello world&#39;})向info集合中插入一条文档，再使用show dbs就能看到order数据库了12345678910111213141516171819&gt; use orderswitched to db order&gt; dborder&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBschool 0.000GBtest 0.000GB&gt; db.info.insert(&#123;'name':'张三','note':'hello world'&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBorder 0.000GBschool 0.000GBtest 0.000GB 删除数据库可以使用db.dropDatabase()删除当前数据库，再使用show dbs查看当前数据库是否删除，可以看到school已经不存在了（好奇的人，这时候也许会问：我在当前数据库下删除其他数据库可以吗？我试了下，好像不行，报错了……）123456789101112&gt; use schoolswitched to db school&gt; dbschool&gt; db.dropDatabase()&#123; "dropped" : "school", "ok" : 1 &#125;&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBorder 0.000GBtest 0.000GB 集合（collection）创建集合创建集合的语法为db.createCollection(name, options)，第一个参数name是必传的集合名，第二个options是指定有关内存大小及索引的选项的可选参数，例如，我们使用命令db.createCollection(&#39;goods&#39;)在order数据库下新建一个goods集合，然后使用show collections或show tables命令查看该数据库下的文档12345678910&gt; use orderswitched to db order&gt; db.createCollection('goods')&#123; "ok" : 1 &#125;&gt; show collectionsgoodsinfo&gt; show tablesgoodsinfo 能不能不用预先创建集合？当然是可以的，其实在MongoDB中，我们不需要先创建集合，因为当你插入文档后，MongoDB会自动创建该集合，例如，我们使用db.user.insert({&#39;name&#39;:&#39;lisan&#39;,&#39;age&#39;:23,&#39;sex&#39;:&#39;w&#39;})在order数据库中创建user集合并插入一条文档123456789&gt; show tablesgoodsinfo&gt; db.user.insert(&#123;'name':'lisan','age':23,'sex':'w'&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; show collectionsgoodsinfouser 删除集合创建了集合，那么肯定就需要删除多余的集合，删除集合的语法为db.collectionName.drop()，例如，我们使用db.user.drop()删除刚刚创建的user集合12345&gt; db.user.drop()true&gt; show collectionsgoodsinfo 友情帮助：对了，可以使用db.collectionName.help()查看集合的帮助，例如：db.goods.help() 文档（document）插入文档MongoDB使用insert()方法向集合中插入文档，语法为db.collectionName.insert(document)，例如使用db.goods.insert({&#39;name&#39;:&#39;商品名称&#39;,&#39;price&#39;:123,&#39;sale&#39;:6})向goods集合中插入一条数据（当我们插入一条文档的时MongoDB会自动为此文档生成一个_id属性，且_id的值一定是唯一的，默认为objectId()）12&gt; db.goods.insert(&#123;'name':'商品名称','price':123,'sale':6&#125;)WriteResult(&#123; "nInserted" : 1 &#125;) 插入文档的其他方法插入文档，还是可以使用db.collectionName.insertOne(document)插入一条或者使用db.collectionName.insertMany(document)插入多条，insertOne()的使用和insert()一样的，document都是一个json对象；insertMany()插入多条时，document是多个json对象的数组，示例如下：12345678910111213&gt; db.goods.insertOne(&#123;'name':'商品名称6','price':19,'sale':9&#125;)))) "acknowledged" : true, "insertedId" : ObjectId("5e953450aabbbfa8f930a967")&#125;&gt; db.goods.insertMany([&#123;'name':'商品名称88','price':18,'sale':1&#125;,&#123;'name':'商品名称99','price':99,'sale':99&#125;]))) "acknowledged" : true, "insertedIds" : [ ObjectId("5e953475aabbbfa8f930a968"), ObjectId("5e953475aabbbfa8f930a969") ]&#125; 另外，插入文档也可以使用db.collectionName.save(document)命令。如果不指定_id字段save()方法类似于insert()方法。如果指定_id字段，则会更新该_id的数据。 更新文档MongoDB使用update()方法来更新集合中的文档，语法如下：123456789db.collectionName.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 前面，我们再goods集合中插入了一条{&#39;name&#39;:&#39;商品名称6&#39;,&#39;price&#39;:19,&#39;sale&#39;:9}的文档，现在我们更新这个文档，把名称 name=商品名称6 的价格 price 改为91，则更新命令为db.goods.update({&#39;name&#39;:&#39;商品名称6&#39;}, {$set:{&#39;price&#39;:91}})，更新前后对比发现确实变了1234567891011121314&gt; db.goods.find()&#123; "_id" : ObjectId("5e95322caabbbfa8f930a965"), "name" : "商品名称", "price" : 123, "sale" : 6 &#125;&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称6", "price" : 19, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称88", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125;&gt; db.goods.update(&#123;'name':'商品名称6'&#125;, &#123;$set:&#123;'price':91&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.goods.find() 1&#125;&#125;)&#123; "_id" : ObjectId("5e95322caabbbfa8f930a965"), "name" : "商品名称", "price" : 123, "sale" : 6 &#125;&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称6", "price" : 91, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称88", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125; 也可以通过save()方法通过传入的文档来替换已有文档，必须传入_id的值 部分更新操作符上面的update命令中，可能你会问\$set那个是什么意思呢？这是操作符，用来指定设置文档某字段的值，还有其他很多更新操作符，下面大概列一下： $unset：删除指定字段 $inc：给一个字段增加指定数值 $pop：删除数组字段中的第一个或最后一个元素 $push：向数组中追加一个值 $pushAll：向数组中追加多个指定值 $pull：符合条件的值将被删除 其他…… 其他更新文档说明另外，update()默认只会更新符合条件的第一条数据，如果需要全部更新，则需要指定multi的值为true，例如下面的数据，我提前把两条文档的price改为18，然后把这两条文档的name改为“商品名称相同”，可以看到执行一次，两条数据都变了1234567891011121314&gt; db.goods.find() e&#125;&#125;)&#123; "_id" : ObjectId("5e95322caabbbfa8f930a965"), "name" : "商品名称", "price" : 123, "sale" : 6 &#125;&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称6", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称88", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125;&gt; db.goods.update(&#123;'price':18&#125;, &#123;$set:&#123;'name':'商品名称相同'&#125;&#125;, &#123;multi: true&#125;)WriteResult(&#123; "nMatched" : 2, "nUpserted" : 0, "nModified" : 2 &#125;)&gt; db.goods.find() true&#125;)&#123; "_id" : ObjectId("5e95322caabbbfa8f930a965"), "name" : "商品名称", "price" : 123, "sale" : 6 &#125;&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称相同", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125; 还有，在3.2版本开始，MongoDB还提供了db.collectionName.updateOne()更新一个文档，db.collectionName.updateMany()更新多个文档，更新单个和update相同，传入前两个参数即可，使用updateMany()更新多个更加方便，不必传入multi为true了 删除文档MongoDB使用remove()来移除文档，其语法如下1234567db.collectionName.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 我们使用remove()来移除goods集合中 name=商品名称 的文档，其命令为db.goods.remove({&#39;goods&#39;: &#39;商品名称&#39;})1234567&gt; db.goods.remove(&#123;'name': '商品名称'&#125;))WriteResult(&#123; "nRemoved" : 1 &#125;)&gt; db.goods.find()&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称相同", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125; 其他删除文档说明 执行删除操作的时候，默认是删除所有符合条件的数据，如果你想删除指定的最多条数，则在第二个参数传入该限制数字：db.goods.remove({&#39;goods&#39;: &#39;商品名称&#39;}, 2)，如果你想删除集合的全部文档传入空对象即可，也就是db.goods.remove({}) remove()方法已经过时了，现在官方推荐使用 deleteOne()删除单个文档 和 delete；Many()删除多个文档，例如删除多个的命令为db.goods.deleteOne({&#39;goods&#39;: &#39;商品名称&#39;})，删除多个的命令为db.goods.deleteMany({&#39;goods&#39;: &#39;商品名称&#39;}) 查询文档MongoDB 查询文档使用 find() 方法，其语法为db.collectionName.find(query, projection)，两个参数都是可选的（其中query是查询条件，projection是返回字段），啥都不传默认查询全部文档的全部字段查找goods集合的全部文档，命令为db.goods.find()1234567891011121314&gt; db.goods.find()&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称相同", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125;查找goods集合sale大于6的文档，命令为db.goods.find(&#123;'sale': &#123;$gt: 6&#125;&#125;)&gt; db.goods.find(&#123;'sale': &#123;$gt: 6&#125;&#125;)&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125;查找goods集合sale大于6且price小于20的文档，命令为db.goods.find(&#123;'sale': &#123;$gt: 6&#125;, 'price': &#123;$lt: 20&#125;&#125;)&gt; db.goods.find(&#123;'sale': &#123;$gt: 6&#125;, 'price': &#123;$lt: 20&#125;&#125;)&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125; 条件操作符说明从上面的查询命令中，可能有人会注意到，\$gt或者\$lt这是什么意思呢，这是条件操作符，具体部分操作符如下： $gt：查找字段值大于指定值的文档 $lt：查找字段值小于指定值的文档 $gte：查找字段值大于等于指定值的文档 $lte：查找字段值小于等于指定值的文档 $in：查找字段值等于指定数组中的任何值 $nin：字段值不在指定数组或者不存在 $or：文档至少满足其中的一个表达式 $eq：查找字段值等于指定值的文档 $ne：查找字段值不等于指定值的文档，包括没有这个字段的文档 其他…… 正则匹配的模糊查询另外，关于一些模糊查询，MongoDB还支持正则匹配，语法为：db.collectionName.find({key:/value/})，例如下面的查询12345678910&gt; db.goods.find(&#123;'name': /99/&#125;))))&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125;&gt; db.goods.find(&#123;'name': /相同$/&#125;))&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称相同", "price" : 18, "sale" : 1 &#125;&gt; db.goods.find(&#123;'name': /^商品/&#125;)&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称相同", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125; 分页限制查询我们知道find()查询默认返回符合条件的全部文档，如果想只查询指定条数呢，这时候就需要用到limit()方法了，其语法为db.collectionName.find().limit(number) limit()是返回符合条件的前几条数据，如果我想返回中间的几条数据，该怎么取？这时候同样需要skip()方法来跳过指定数量的记录数，其语法为db.collectionName.find().limit(number).skip(number) 上面的goods集合中，我们想跳过前三条获取第四条name为“商品名称99”的数据，其命令为db.goods.find().limit(1).skip(3)12&gt; db.goods.find().limit(1).skip(3)&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125; 排序查询在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。排序查找的基本语法为db.collectionName.find().sort({key:1}) 例如上面的goods集合，我们想查询结果按照sale升序排序，则命令为db.goods.find().sort({&#39;sale&#39;: 1})12345&gt; db.goods.find().sort(&#123;'sale': 1&#125;)&#123; "_id" : ObjectId("5e953475aabbbfa8f930a968"), "name" : "商品名称相同", "price" : 18, "sale" : 1 &#125;&#123; "_id" : ObjectId("5e95340faabbbfa8f930a966"), "name" : "商品名称1", "price" : 19.99, "sale" : 8 &#125;&#123; "_id" : ObjectId("5e953450aabbbfa8f930a967"), "name" : "商品名称相同", "price" : 18, "sale" : 9 &#125;&#123; "_id" : ObjectId("5e953475aabbbfa8f930a969"), "name" : "商品名称99", "price" : 99, "sale" : 99 &#125; 温馨提示：这里需要说明一下，当skip()、limilt()和sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit() 最后说明到了这里，相信大家对于MongoDB的基础用法都会了，如果需要了解更多，可以查找相关的教程和官方说明，如有说的不对或者不全的，请大家指出，我会及时改正，谢谢。]]></content>
      <tags>
        <tag>程序员</tag>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离京开始深漂的第一年]]></title>
    <url>%2F2020%2F04%2F13%2F%E7%A6%BB%E4%BA%AC%E5%BC%80%E5%A7%8B%E6%B7%B1%E6%BC%82%E7%9A%84%E7%AC%AC%E4%B8%80%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[离京缘由在北京的最后一家公司，是做汽车租赁业务的，我是17年初的时候入职的，到2019年初已经有两年了，公司氛围和同事关系都非常好，但是到了2018年下半年，公司分批开始裁员，我们技术部四五十号人，一个一个的走了，我是属于最后一批离职的，这个时候没几天就过年了，所以离职后，也没有继续找工作直接回家过年了…… 因为我是广西人，在家过期间，也和家里人讨论过，不去北京那么远了，考虑回南方这边，离家更近，回家更方便的地方，也就是广州或者深圳了，毕竟这两个地方的互联网环境还是不错的，所以过完年，我先回了北京，处理一些事情，比如退房和整理自己的行李啥的，当然了，少不了三五好友聚聚告别。 说实在的，毕竟在北京呆了三年多，想想突然要离开了，确实心里有点小小的别样滋味，但是一段旅程的结束是为了追求另一段更好旅程的开始！ 选择深圳告别北京，拖上我的行李箱，搭乘前往广州的高铁，开始另一段旅程，我的第一站是广州，寄住在同学那里（我广州和深圳好多同学的），因为我想先在广州找找工作，看能否有合适我的，在广州停留了大概十来天吧，也面试了好多家公司，也拿到了几家offer，但是综合考虑，并不太适合我，所以，我选择放弃，并于一个周末，继续拖着行李箱告别广州，搭乘高铁前往了深圳…… 晚上到了深圳，不说假话，这是我人生第一次踏上深圳这个城市，那种陌生感，那种对于前途的未知感迎面袭来，但是，我想我能在这开始一段不错的旅程，既来之必安之，别无选择，只能一路向前！刚到深圳，完全陌生的城市，开始了我的求职面试之旅，去过南山科技园，到过龙华新区，当然也去过福田CBD，经过一轮又一轮的面试，offer也陆续收到，并最终选择福田区车公庙的一家做B2B的电商公司。 我的工作我负责的是PHP后端的开发，我在入职之前，有查过公司的相关信息，以及研发的项目，但是在我入职之后，却发现，有另外的团队在研发那个项目，而我需要协助另外的一个新项目，而在我之前只有一个后端小哥在开发这个项目，是一个B2B的电商项目，包括PC和APP两个端，而我则主要负责PC相关的开发。 项目从开发到上线，几个月的时间里已经由于产品设计，变化了好几个版本，而更加奇葩的是，项目部署的方式，竟然是FTP手动拖代码的方式进行部署，太可怕了，我的小心脏一直在跳动，承受着这个年纪不该有的压力和责任（后面已在我们的建议下改为Jenkins自动部署）。项目团队成员也在逐步增加，但是一直没有一个懂技术且负责任的leader，这很头大，小的们也是空有一身本领得不到认可，无法使劲干啊，这也导致了项目中期走了很多的弯路和错路，并最终又要回到原点重新出发的那种…… 蜗居生活不管是北漂还是深漂或者其他的外出奔波的人，总避免不了要找个临时的住所，有的人住在天桥底下，有的人住在马路边上，有的人住在无人的广场上，也有人住着简陋的地下室，而城中村租房，则成为了我们很多人的不二选择，我也就是这样。 深圳的房租，和北京相比，稍微便宜一点，但是也差不了多少，我记得，我刚来深圳的生活，自己在宝安西乡那边租了个单间公寓，就租了一个月，结果亏了1个月的房租，心痛啊；然后就选择和同学合租，到了龙华新区的上塘那附近，房租稍微便宜点，住了3个月，天天挤着深圳最拥挤的地铁4号线上下班，更关键的是，那附近真的是太吵了，所以再一次搬家；也就是现在住的福田上沙这里，相对好一点，不用享受着挤地铁的快乐，不用再生活在乐市之中…… 闲暇时间到深圳的这一年，周边去过广州、珠海、惠州以及清远；而市区内，去过世界之窗看世界，去过小梅沙游泳，去过深圳湾公园海边散步遥望香港，去过东部华侨城感受郊区别样风景…… 在外能文，在内能武，文武兼备。很多年都不玩PC端游了，所以，平时也就玩一些手机游戏，比如王者农药啊，大吉大利今晚吃鸡啊，别走决战到天亮的斗地主啊，时刻想着天胡地胡的麻将啊，当然也偶尔玩一些其他小游戏啥的啊，总之就是哪里有队友需要我，我就在哪里出现（吃鸡手雷炸队友，喝药喊打团果断卖队友自己跑路，斗地主用牌压制队友帮着地主赢，我就是全网最全能的小战士）。 玩够了，当然不能忘了活到老学到老，因为不学习不进步就是退步，所以，平时都会买点书看看，逛技术论坛和社区，扩展技术范围，向大佬们学习，力争做像大佬们一样优秀的人（这个别当真，我就说说而已）， 最后寄语2020年，由于新冠病毒的影响，不管是企业还是个人，不管是在职的或者正在求职的，都是非常艰难的一段时间，但是相信艰难的日子总会过去，迎来光明，走向希望……]]></content>
      <tags>
        <tag>深圳</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段之jQuery控制input只能输入数字和两位小数]]></title>
    <url>%2F2019%2F05%2F16%2F%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E4%B9%8BjQuery%E6%8E%A7%E5%88%B6input%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5%E6%95%B0%E5%AD%97%E5%92%8C%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言做为一个PHPER，难免会遇到那种表单中jQuery限制输入的问题，比如，限制空格的输入，只允许输入数字，以及小数点的控制等等，这里，我们就说一下数字的限制。 jquery代码话不多说，直接先上jQuery函数，具体的可以看注释说明，在使用这个之前，请务必保证已经提前引入了jQuery库，大家可以自己下载一个jQuery文件，然后引入，也可以查找CDN地址引入，比如在https://www.bootcdn.cn/jquery/可以查找到很多版本的引入地址，直接找到你想要的引入就行。 1234567891011121314&lt;script&gt; // 格式化限制数字文本框输入，只能数字或者两位小数 function format_input_num(obj)&#123; // 清除"数字"和"."以外的字符 obj.value = obj.value.replace(/[^\d.]/g,""); // 验证第一个字符是数字 obj.value = obj.value.replace(/^\./g,""); // 只保留第一个, 清除多余的 obj.value = obj.value.replace(/\.&#123;2,&#125;/g,"."); obj.value = obj.value.replace(".","$#$").replace(/\./g,"").replace("$#$","."); // 只能输入两个小数 obj.value = obj.value.replace(/^(\-)*(\d+)\.(\d\d).*$/,'$1$2.$3'); &#125;&lt;/script&gt; 函数的直接用法之onkeyup在input表单输入中，限制最多只能保留两位小数点，其他自动抹掉；这里会用到onkeyup事件，也就是onkeyup事件会在键盘按键被松开时发生，也就是，这个时候调用我们的函数，来处理已输入的内容。 1&lt;input type="text" onkeyup="format_input_num(this)" value="" size="10" /&gt;元 函数的直接用法之blur除了上面的监控键盘事件外，还可以通过监控表单的焦点事件来实现，也就是，表单都有获得焦点事件focus和失去焦点事件blur，我们只需要在失去焦点的时候，调用我们的format_input_num函数就可以了，具体如下： 1&lt;input type="text" onblur="format_input_num(this)" value="" size="10" /&gt;元 或者不在表单中直接绑定方法，而是去jQuery中通过查找元素节点，然后单独绑定相应的事件，并执行相关函数 123456&lt;input type="text" value="" size="10" id="money" /&gt;元&lt;script&gt; $("#money").off('blur').on('blur', function()&#123; format_input_num(this); &#125;);&lt;/script&gt; 其他输入限制限制只能输入数字的写法，也就是，只能输入0-9的数字 1&lt;input type="text" onkeyup='this.value=this.value.replace(/\D/gi,"")' /&gt; 限制只能输入数字、字母和横线”-“，其中字母包括大小写 1&lt;input type="text" onkeyup='value=value.replace(/[^A-Za-z0-9\-]+/g,"")' /&gt; 当然了，还有其他很多校验规则，可以自己根据实际需求进行修改和尝试一下 最后这就是我分享CODING过程中的一些代码片段，有不对或者需要优化的地方，大家可以给我留言。 感谢http://www.cnblogs.com/angto64/p/5459496.html]]></content>
      <tags>
        <tag>代码片段</tag>
        <tag>jQuery</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北漂之毕业裁员后的又一波奇遇]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%8C%97%E6%BC%82%E4%B9%8B%E6%AF%95%E4%B8%9A%E8%A3%81%E5%91%98%E5%90%8E%E7%9A%84%E5%8F%88%E4%B8%80%E6%B3%A2%E5%A5%87%E9%81%87%2F</url>
    <content type="text"><![CDATA[前言之前说到，一毕业，实习的公司，就面临着转型，然后裁员，接着说一下，毕业之后，入职的第一家公司的遭遇吧。 快速找到新单位离职当天下午，CTO找了我，说有一个朋友的公司，是一个小公司，刚拿到融资的，是做类似社区服务的，主要是在亚运村盘古大观那里，做一个为那里的上班族代收快递、午餐供应，以及一些小零食水果的线上供应的相关功能，并且推荐我和另外一个同事一起去，当时，谈的待遇还可以，说那边功能需求挺急的，要求一个月内上线，所以，我们两当天办理好离职手续后，第二天，就直接去那边入职了。这时候，大概是7月中旬吧。 公司项目线上商城到了那边后，我们的第一个项目，就是弄一个微信公众号端的H5商城，也就是，卖一些盒饭呀，水果呀，零食呀啥的，刚去，由于说项目需要尽快上线，由于后端技术，只有我们两个人，所以，我们那段时间，也折腾了好一会，我大概记得，就那个H5的商城，还没上线，前端都改版了至少三四次，老板说这不行，那不行的，但是都是按照老板自己的想法来的，真的是自己打脸，反正没我们后端啥事，主要是前端的在折腾，我们也是服了。 代收快递我也忘了大概是啥时候，老板说需要代收快递功能也一起上线，所以，我们就设计并开发代收快递的这个相关功能，也都是基于微信公众号端开发的，由于是从0开发的，业务也不是很复杂，所以，我们开发也比较快，但是，功能做完之后，并没有马上上线，好像，还是前端的页面吧，七七八八的，改来改去。 中粮项目由于我们做完了公司自己的项目后，空闲了一段时间，项目也并没有准备好上线，不知道老板哪里来的关系，忽悠了一个中粮食品的项目来做，据说这个项目，之前是外包给人做的，但是那边的人不给源码，所以，被老板忽悠，重写一套这个系统。然后就交由我们来做了，为了做这个项目，我们又叫来了一个认识的朋友，一起做，也就是，这个时候，我们是三个后端了，我们三也都是兢兢业业的配合做完了这个外包项目。 项目上线大概9月初，公司项目准备都准备好，终于可以上线了，上线后，商城并没有什么人下单，反倒是代收快递那里，线下的人忙的不可开交，但是有啥用？代收一个快递也挣不来几个钱，最终，为了能卖出更多的盒饭以及零食啥的，老板自己去到线下去开始搞活动，找一个摊位，去卖盒饭，但是，发现，买你盒饭的人，都是直接扫码付款的，并不愿意走你公众号的商城去下单，也就是，这个项目做完了，没有什么人用。 技术团队解散随着做完的项目没有人用，发现直接线下付款卖盒饭和小零食更加方便和快捷，所以，也就是在项目上线后的一个周左右，也就是大概九月中旬，老板有想法，为了节约成本，还想要让我们去他家办公，真的是搞笑吧，最终，还是解散了技术团队，时间大概在9月20号左右。也就是，我们几个将面临国庆长假失业的窘境…… 最后这个公司，我们大概就干了两个月左右的时间，项目就坚持不下去了，当时我们三的关系也挺好，所以，我们三个也有想法一起找一个公司继续干，但最终，没有合适的，所以，离职后，就各自开始找下家……这都是国庆后的事了]]></content>
      <tags>
        <tag>个人经历</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北漂之实习生经历]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%8C%97%E6%BC%82%E4%B9%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前言很多专业，到了大四，实习期只有几个月，甚至更短，但是我们计算机专业，一般到了大四，要么就是留校复习考研的，或者留校备考公务员的，又或者留校准备毕业自己创业当老板的，而那些在编程道路上迷途不知返的人，一般都会选择出去找个编程相关的实习机会，有去广州、深圳的，也有去北京、上海的，总之，都是去大城市，毕竟小城市，互联网行业还是不太景气，收入也不是很客观，大城市才是最终归宿……而我也一样，选择走上了这条不归路，来到了帝都–北京。 开始面试，很顺利大概是2015年11月中旬这样，开始出去面试，面试的第一天，刚好是周五，我记得，这一天，大概面试了三、四家吧，真的是非常的幸运，有两家公司愿意给我一个实习的机会，都是做电商的，只不过针对的消费群体不一样，一个是面向乡镇的消费群体，一个是跨境电商，最终，我决定选择去了这个跨境电商的公司，入职时间就在下周一，而且，非常幸运的是，一起入职的还有一个认识的朋友，然后，我们就组成了一起上下班的铁搭档。 入职报道我记得，这一天，由于我们住的比较远，住在昌平区的七里渠这里，公司在朝阳区的三间房东路那里，所以我们大概七点钟左右出门，天气贼冷的那种，但是我们俩到的挺早的，大概提前半个小时到了公司门口，发现公司还没有开门，我们就在门口晃悠了一下，等到差不多九点钟的时候，就进去了，入职无非都是办理相关手续呀，然后介绍认识一下团队里的Leader等，然后就是最最常见的安装系统啊，安装自己工作中需要用到的相关软件等，俗称搭建开发环境，然后熟悉业务和代码啥的…… 公司福利 由于我们是实习生，职场菜鸟，所以，公司给我们在公司马路对面的小区里租了一套房子，两室一厅的，挺大的，大概四个人住，也是挺满足的。 公司管早餐、管午餐，由于住的近，早上十点上班，九点半起床，然后洗漱，走去公司，然后领早餐吃，都来得及，也是挺美滋滋的。 小零食、水果啥的，会不定时供应，应该是每周五下午吧，会固定每人一个小果盘，也是挺惬意的。 其他的公司活动，也是该有的都有，引用抖音上，现在比较火的一句话：“好嗨哦，感觉人生已经到达了巅峰……”。 公司转折点2016年过完年回来不久，公司新来了一个CTO，我们叫他浩哥，非常巧的是，他就是之前我面试的时候，另一家我放弃的公司的面试官；浩哥来公司之后，推荐了一部分他之前公司的人入职，从此，公司的氛围，开始变的不是很好，公司的福利，也是开始慢慢的削减，例如，日常供应的早餐，公司说发现一些人吃不完浪费，直接不再提供了（这理由也是没谁了）；还有，大概在四、五月份左右，也开始了一段时间的加班经历（说是三个月），就是传说中的996上班，说是要赶进度，这引起了团队很多人的不满，但也没有办法。 公司裁员自从996以来，一两个月也过去了，在抱怨和不满的的氛围中，也许大家都已经慢慢习惯了996的上班，大概在六月中旬这样，我请假回校办理毕业手续等，然后大概刚好七月这样吧，继续回到公司，大概也就是在七月10号左右吧，我们的CTO，也就是浩哥，开始逐个找人单聊，我们也不知道是说了啥，问了，也没人说，都是说，过几天都知道了，然后慢慢的，过了几天，轮到找我单聊了，这才知道，原来，公司是要裁员了，我就在其中……由于我是实习生，所以，补偿啥的，也没有，公司只愿意将平时加班的时间，统计，然后给我折现，因为我们刚经历了996，所以每个人的加班时间，都还是不少的，也就拿到这点补偿。 最后临走前，公司的HR，都找我们要简历，说，帮我们投递出去，另外，浩哥，也找了我，说给我推荐一个公司，具体怎么样，且听下回分解……]]></content>
      <tags>
        <tag>个人经历</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬取英雄联盟英雄皮肤大图]]></title>
    <url>%2F2018%2F11%2F14%2FPython3%E7%88%AC%E5%8F%96%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E8%8B%B1%E9%9B%84%E7%9A%AE%E8%82%A4%E5%A4%A7%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言上篇文章，说到了，爬取LOL英雄皮肤的高清图片，最近有事，也没怎么去研究，所以，现在才去看了下，并且写了Python脚本来抓取皮肤图片。需要说明一下，这个脚本有部分英雄没有抓取到，但是具体原因，我目前还没搞懂，我是相当纳闷的。大家有兴趣的，可以看看后面遗留问题，一起研究下。 爬虫思路初步尝试我先查看了network，并没有发现有可用的API；然后又用bs4去分析英雄列表页，但是请求到html里面，并没有英雄列表，在英雄列表的节点上，只有“正在加载中”这样的字样；同样的方法，分析英雄详情也是这种情况，所以我猜测，这些数据应该是Javascript负责加载的。 继续尝试然后我就查看了英雄列表的源代码，查看外部引入的js文件，以及行内的js脚本，大概在368行，发现了有处理英雄列表的js注释，然后继续往下读这些代码，发现了第一个彩蛋，也就是他引入了一个champion.js的文件，我猜测，这个应该就是英雄列表大全了，然后我打开了这个链接的js，一眼看过去，黑麻麻一片，然后格式化了一下压缩的js，确定这就是英雄列表的js数据文件了。 接着尝试前面通过查看列表的源代码，找到了英雄列表的js数据文件，那么，我继续随机点开了一个英雄的详情，然后查看英雄详情源代码，然后大概在568行看到有一个showSkin的js方法，通过这里，发现了第二个彩蛋，也就是皮肤图片的URL地址拼接方法。 最后尝试上面找到了皮肤图片URL的拼接方法，并且发现了一行很关键的代码var skin =LOLherojs.champion[heroid].data.skins，也就是，这个skin变量，就是英雄皮肤的所有图片数组，但是这个文件内，并没有LOLherojs这个变量，也就是外部引入的，所以，需要继续查看下面的源代码，找到引入这个变量的位置，果不其然，在757行，发现了最后一个彩蛋，也就是，英雄皮肤的js文件，通过这里可以知道，每个英雄都有一个单独的js文件，并且知道了这个js文件的URL拼接方法。 思路总结通过上面的分析，我们就得到了爬取LOL皮肤图片的所有数据准备了，也就是，直接，只需要提取js中的英雄列表以及英雄详情数据，就可实现我们的需求了。下面是运行后抓取到的图片…… 运行环境Python运行环境：python3.6用到的模块：requests、json、urllib、os、lxml未安装的模块，请使用pip instatll进行安装，例如：pip install requests 完整代码其他啥的废话就不多说了，直接上完整代码，有问题，直接留言给我就行，另外，代码已上传GitHub。再说明一下，那些有问题的英雄详情的js文件，大家有时间也可以琢磨下，或者有其他的更加快捷的爬取这些图片的方法，也可以拿出来交流和讨论，谢谢。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python# -*- coding: utf-8 -*-"""抓取英雄联盟英雄全皮肤author: gxcuizydate: 2018-11-13"""import requestsimport jsonfrom urllib import parseimport osclass GetLolSkin(object): """抓取LOL英雄皮肤""" def __init__(self): """初始化变量""" self.hero_url = 'https://lol.qq.com/biz/hero/champion.js' self.hero_detail_url = 'http://lol.qq.com/biz/hero/' self.skin_folder = 'skin' self.skin_url = 'https://ossweb-img.qq.com/images/lol/web201310/skin/big' @staticmethod def get_html(url): """下载html""" request = requests.get(url) request.encoding = 'gbk' if request.status_code == 200: return request.text else: return "&#123;&#125;" def get_hero_list(self): """获取英雄的完整信息列表""" hero_js = self.get_html(self.hero_url) # 删除左右的多余信息，得到json数据 out_left = "if(!LOLherojs)var LOLherojs=&#123;&#125;;LOLherojs.champion=" out_right = ';' hero_list = hero_js.replace(out_left, '').rstrip(out_right) return json.loads(hero_list) def get_hero_info(self, hero_id): """获取英雄的详细信息""" # 获取js详情 detail_url = parse.urljoin(self.hero_detail_url, hero_id + '.js') detail_js = self.get_html(detail_url) # 删除左右的多余信息，得到json数据 out_left = "if(!herojs)var herojs=&#123;champion:&#123;&#125;&#125;;herojs['champion'][%s]=" % hero_id out_right = ';' hero_info = detail_js.replace(out_left, '').rstrip(out_right) return json.loads(hero_info) def download_skin_list(self, skin_list, hero_name): """下载皮肤列表""" # 循环下载皮肤 for skin_info in skin_list: # 拼接图片名字 if skin_info['name'] == 'default': skin_name = '默认皮肤' else: if ' ' in skin_info['name']: name_info = skin_info['name'].split(' ') skin_name = name_info[0] else: skin_name = skin_info['name'] hero_skin_name = hero_name + '-' + skin_name + '.jpg' self.download_skin(skin_info['id'], hero_skin_name) def download_skin(self, skin_id, skin_name): """下载皮肤图片""" # 下载图片 img_url = self.skin_url + skin_id + '.jpg' request = requests.get(img_url) if request.status_code == 200: print('downloading……%s' % skin_name) img_path = os.path.join(self.skin_folder, skin_name) with open(img_path, 'wb') as img: img.write(request.content) else: print('img error!') def make_folder(self): """初始化，创建图片文件夹""" if not os.path.exists(self.skin_folder): os.mkdir(self.skin_folder) def run(self): # 获取英雄列表信息 hero_json = self.get_hero_list() hero_keys = hero_json['keys'] # 循环遍历英雄 for hero_id, hero_code in hero_keys.items(): hero_name = hero_json['data'][hero_code]['name'] hero_info = self.get_hero_info(hero_id) if hero_info: skin_list = hero_info['result'][hero_id]['skins'] # 下载皮肤 self.download_skin_list(skin_list, hero_name) else: print('英雄【%s】的皮肤获取有问题……' % hero_name)# 程序执行入口if __name__ == '__main__': lol = GetLolSkin() # 创建图片存储文件 lol.make_folder() # 执行脚本 lol.run()]]></content>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
        <tag>json</tag>
        <tag>英雄联盟</tag>
        <tag>LOL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取王者荣耀英雄皮肤高清图片]]></title>
    <url>%2F2018%2F11%2F07%2FPython%E7%88%AC%E5%8F%96%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E8%8B%B1%E9%9B%84%E7%9A%AE%E8%82%A4%E9%AB%98%E6%B8%85%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言临下班前，看到群里有人在讨论用王者农药的一些皮肤作为电脑的壁纸，什么高清的，什么像素稍低的，网上查了一手，也有，但像素都不一样，所以，我就想着，自己去官网直接爬他的高清皮肤就好了，然后就有了这边文章说的主题了。 爬图思路找到英雄列表进入官网，然后进入英雄介绍，查看更多英雄，就能看到全部的英雄了，也就是下面的这个链接 英雄列表：https://pvp.qq.com/web201605/herolist.shtml 英雄详情点击每个英雄进来，就可以看到每个英雄的详细信息，基本介绍以及皮肤展示，而我们需要爬取的皮肤，就在右下角那里，鼠标放上去，就可以逐个展示该皮肤了 小鲁班的详细信息：https://pvp.qq.com/web201605/herodetail/112.shtml 分析皮肤图片URL从上面的这张鲁班的图片中我们可以看到，通过F12定位到皮肤的小图片位置，li元素里有一个img的元素，其中img的src和data-imgname这两个属性，查看一下，就不难知道，src的属性值是小图，而data-imgname则是我们需要的大图URL，但是查看源码，就会发现，在html中，并没有这个属性，所以，需要我们分析这个URL的规律来得到其他英雄的皮肤图片，分析也不难发现，112就是英雄的id，而bigskin-2里面的2即表示这个英雄的第几张皮肤图片 开始编写爬虫脚本第一步：定义一些常用变量 第二步：抓取所有英雄列表 第三步：循环遍历，分析每个英雄皮肤节点 第四步：下载图片 第五步：爬虫结束 完整源码感觉上面七七八八的，说了些啥呀，真是墨迹，还不如直接上代码实在，好吧，我错了，马上交出源码，请各位看官饶恕，同时，代码我也上传了交友网站GitHub。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/env python# -*- coding: utf-8 -*-"""抓取王者荣耀皮肤author: gxcuizydate: 2018-11-06"""import requestsfrom bs4 import BeautifulSoupfrom urllib import parseimport osclass Skin(object): def __init__(self): # 英雄的json数据 self.hero_url = 'https://pvp.qq.com/web201605/js/herolist.json' # 英雄详细页的通用url前缀信息 self.base_url = 'https://pvp.qq.com/web201605/herodetail/' # 英雄详细页url后缀信息 self.detail_url = '' # 图片存储文件夹 self.img_folder = 'skin' # 图片url的通用前缀 self.skin_url = 'https://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/' # 图片url的后缀信息 self.skin_detail_url = '' def get_hero(self): """获取英雄的json数据""" request = requests.get(self.hero_url) hero_list = request.json() return hero_list def get_hero_skin(self, hero_name, hero_no): """获取详细页英雄皮肤展示的信息，并爬图""" url = parse.urljoin(self.base_url, self.detail_url) request = requests.get(url) request.encoding = 'gbk' html = request.text # 获取皮肤信息的节点 soup = BeautifulSoup(html, 'lxml') skip_list = soup.select('.pic-pf-list3') for skin_info in skip_list: # 获取皮肤名称 img_names = skin_info.attrs['data-imgname'] name_list = img_names.split('|') skin_no = len(name_list) # 循环下载皮肤图片 for skin_name in name_list: self.skin_detail_url = '%s/%s-bigskin-%s.jpg' % (hero_no, hero_no, skin_no) skin_no -= 1 img_name = hero_name + '-' + skin_name + '.jpg' self.download_skin(img_name) def download_skin(self, img_name): """下载皮肤图片""" img_url = parse.urljoin(self.skin_url, self.skin_detail_url) request = requests.get(img_url) if request.status_code == 200: print('download-%s' % img_name) img_path = os.path.join(self.img_folder, img_name) with open(img_path, 'wb') as img: img.write(request.content) else: print('img error!') def make_folder(self): """创建图片存储文件夹""" if not os.path.exists(self.img_folder): os.mkdir(self.img_folder) def run(self): """脚本执行入口""" self.make_folder() hero_list = self.get_hero() for hero in hero_list: hero_no = str(hero['ename']) self.detail_url = hero_no + '.shtml' hero_name = hero['cname'] self.get_hero_skin(hero_name, hero_no)# 程序执行入口if __name__ == '__main__': skin = Skin() skin.run() 最后其实思路就是这么简单，当然了，如果有其他思路以及想法的，欢迎留言交流。额，差点忘了，大家有兴趣的，可以尝试一下爬取英雄联盟的所有英雄皮肤高清图片，有其他任何问题，也欢迎留言和交流。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
        <tag>bs4</tag>
        <tag>王者荣耀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的依赖包之pip管理工具的基础使用]]></title>
    <url>%2F2018%2F10%2F26%2FPython%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85%E4%B9%8Bpip%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[pip是什么我们都知道Python很强大，实用性也非常高，其很重要的一个原因就是因为有非常丰富的第三方库类，而pip是Python的的依赖包管理工具，该工具提供了对Python包的查找、下载、安装、卸载等的功能。基本使用到的包都可以在https://pypi.org/上面搜索找到。当然了，官网的包可能涉及翻墙访问的问题，也可以使用国内的镜像，例如豆瓣的镜像http://pypi.douban.com/simple/、清华的镜像https://pypi.tuna.tsinghua.edu.cn/simple等…… 安装pip具体的安装方法可以查看官网的安装说明 官方安装说明地址：https://pip.pypa.io/en/latest/installing/#id7 Windows的用户，需要先到官网下载get-pip.py安装包，然后执行python get-pip.py进行安装 而如果需要在Linux上安装的话，则比较方便和快捷的，直接可以通过yum或者apt-get安装即可 yum安装1sudo yum install python-pip apt-get安装1sudo apt-get install python-pip 更多安装方法请安装文档：https://packaging.python.org/guides/installing-using-linux-tools/#installing-pip-setuptools-wheel-with-linux-package-managers 查看pip版本简写方式1pip -V 完整命令方式1pip --version 利用pip安装模块1pip install [module_name] 查看所有已安装的模块1pip list 如果需要搜索指定的模块的话，可以使用下面的命令 1pip search [module_name] 还可以使用下面的方法（PS：好像不是全起作用） 1pip list | grep [module_name] 查看已安装的某个模块的详细信息1pip show --files [module_name] 检查哪些模块需要更新1pip list --outdated 升级指定的模块1pip install --U [module_name] 卸载已经安装的模块1pip uninstall [module_name] 需要查看更多pip的用法1pip --help 更新pip本身Windows的用户执行下面的命令 1python -m pip install -U pip Linux或者Mac OS的用户执行下面的命令 1pip install -U pip]]></content>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题之计算哪一桶是红酒]]></title>
    <url>%2F2018%2F09%2F29%2F%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%93%AA%E4%B8%80%E6%A1%B6%E6%98%AF%E7%BA%A2%E9%85%92%2F</url>
    <content type="text"><![CDATA[算法原题莫斯科的一位酒商现有六桶酒，容量分别为30升、32升、36升、38升、40升、62升。白酒五桶，红酒一桶。他的酒都是整桶出售，上午卖出了两桶白酒，下午卖出的白酒是上午的两倍。请问：红酒是哪一桶？ 算法思路由于总共有六桶酒，其中白酒五桶，红酒一桶；那么也就是说，下午卖出的N桶白酒的升数是早上卖出的两桶白酒升数的两倍，由于没说明下午卖出了多少桶，所以N是不确定的，也就是N的范围是1-3；但是，从六桶酒可以知道，升数最小的是30升和32升，这两个数的和为62升，那么下午至少卖出124升，即N桶的升数不能小于124，再看看其他桶的升数，所以N只能是3；也就是最终知道，早上卖出两桶白酒，下午卖出三桶白酒，并且早上两桶白酒的升数的两倍等于下午卖出的三桶白酒的升数，然后剩下的一桶就是红酒了。 算法源码12345678910111213141516171819202122232425262728293031323334353637// 六桶酒的升数数组$arr = [30, 32, 36, 38, 40, 62];$len = count($arr);// 随机取两桶假设为白酒for ($i = 0; $i &lt; $len-1; $i++) &#123; for ($j = 1 + $i; $j &lt; $len; $j++) &#123; $twoArr = $arr; // 去掉早上卖出的两桶白酒 unset($twoArr[$i]); unset($twoArr[$j]); $twoArr = array_values($twoArr); // 从剩下的取出三桶假设为白酒 for ($n = 0; $n &lt; $len - 4; $n++) &#123; for ($m = 1 + $n; $m &lt; $len - 3; $m++) &#123; for ($p = 1 + $m; $p &lt; $len - 2; $p++) &#123; // 早上白酒总和 $oneSum = $arr[$i] + $arr[$j]; // 下午白酒总和 $twoSum = $twoArr[$n] + $twoArr[$m] + $twoArr[$p]; // 如果早上卖出白酒的升数的两倍等于下午卖出白酒的升数，那么即符合所求 if ($oneSum * 2 == $twoSum) &#123; echo '早上卖出的白酒是：' . $arr[$i] . '、'. $arr[$j] . '&lt;br&gt;'; echo '下午卖出的白酒是：' . $twoArr[$n] . '、'. $twoArr[$m] . '、'. $twoArr[$p] . '&lt;br&gt;'; echo '所有五桶白酒是：' . $arr[$i] . '、'. $arr[$j] . '、'. $twoArr[$n] . '、'. $twoArr[$m] . '、'. $twoArr[$p] . '&lt;br&gt;'; $tmpArr = $twoArr; // 去掉下午卖出的三桶白酒 unset($tmpArr[$n]); unset($tmpArr[$m]); unset($tmpArr[$p]); // 剩下的一桶就是所求红酒 echo '一桶红酒是：' . current($tmpArr) . '&lt;hr&gt;'; &#125; &#125; &#125; &#125; &#125;&#125; 最后这只我的一种思路和实现方法，算法也不是很优，其他的实现算法还有很多，欢迎大家评论留言，实现语言和方式不限，谢谢。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google/Baidu的搜索技巧]]></title>
    <url>%2F2018%2F09%2F27%2FGoogle-Baidu%E7%9A%84%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言关于搜索问题答案的技能，据不知道从哪里来的调查结果显示，让人意外的是有四分之三的人都没能较好的利用网络搜索。在咨询丰富的互联网中，如何有效地搜索那可是快速寻找答案的关键技能啊；这里给您提供了一些有效利用Google/Baidu搜索的提示，助你快速搜获所需信息。 如何Google/Baidu搜索你是否每次在Google/Baidu时都只是假如空格分隔关键字呢？相对这基本的搜索功能，合理利用搜索“操作符”，可以帮助你获得更加精确的搜索结果。Google搜索地址为“https://www.google.com”,Baidu搜索地址为“https://www.baidu.com”。 site搜索搜索语法：site:url.com ~synonym “keywords” -excludeKey 2016..2018 site:url.com表示只搜索某个网站的页面 ~synonym表示同时搜索近义词 “keywords”表示以整个短语作为搜索关键字，而不是拆开为每个词 -excludeKey表示排除某个关键字 2016..2018表示指定年份时间段内的搜索结果 filetype搜索搜索语法：filetype:pdf keywords inititle:titleName of *PHP filetype:pdf指明只搜索类型为pdf的文档，也可以搜索doc、xls、jpg等所有类型的文档 keywords是关键字搜索 inititle:titleName是指明标题中包含指定关键词的搜索结果 *星号用来代替任意字符，即搜索任意字符+关键字的搜索结果 Google/Baidu学术搜索对于很多在学术研究的多数项目中，只依靠简单的Google/Baidu搜索不能有效达到目的；可以借助使用Google/Baidu学术搜索，其专门用来搜索理论和学术著作的，就是你会在你的论文中引用的那种，其Google学术地址为“https://scholar.google.com”，Baidu学术地址为“http://xueshu.baidu.com”。 author搜索搜索语法：author:name keywords “otherKeywords” author:name只表示搜索name发布的论文 keywords就是普通的关键字搜索 “otherKeywords”前面也说了，表示以整个短语作为搜索关键字，而不是拆开为每个词 其他Google/Baidu搜索技巧其他的搜索技巧还有类似字词定义，数学计算，单位换算等，下面一一罗列。 define字词定义快速查询字词定义，只要在你想了解的单词前面输入define即可，即define:keywords 数学计算快速计算，别费力启动你的计算器软件了；只需要直接在Google/Baidu中输入数学算式就行了，算式可以包含+、-、、/和括号这些基本的算术功能。例如：`(48)/2+18-1`。 单位换算方便的单位换算，只需要输入你想要换算的两种单位即可，例如：100磅=?公斤 快捷键操作我相信很多互联网用户不知道可以使用“Ctrl + F”在本页内查找字符。（PS：快捷键的使用在Windows和Mac上略有不同，本文主要以Windows快捷键为例子说明。如果你使用的是Mac，多数情况用“Command”按钮代替“Ctrl”按钮即可。） 在本页内查找关键字查找中最重要的快捷键，在你正在查看的任一文档或者页面中，按下“Ctrl + F”键，弹出搜索框后，输入你想查找的字符串，立刻所有对应的字符串都会高亮显示。 放大或缩小页面有时候页面字体太小或者在线PDF文档勉强可以阅读，从而需要放大或者缩小页面的需求，你就可以使用“Ctrl + 加号+”或者“Ctrl + 减号-”来放大或者缩小当前页面。 选址浏览器地址栏每次使用鼠标移动到地址栏是费神又费力，只要按下“Ctrl + L”或者“F6”，地址栏即可选中。 切换标签页和程序在电脑上工作，随着每天工作的开展，运行的应用程序和打开的窗口越来越多，这个时候，可以使用快捷键帮助你在不同的窗口和应用程序间切换，减轻你的烦乱。切换标签页的快捷键为“Ctrl + Tab”，切换窗口快捷键为“Alt Tab” 最后提示 善用你的大脑、书籍。（PS：Google/Baidu搜索固然很给力，但绝不是搜索结果的唯一选择） 学术搜索不要引用维基百科。（PS：维基百科是一个很适合入门的地方，但是很多资料缺乏来源引证） 其他……]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MySQL优化的几点总结]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%85%B3%E4%BA%8EMySQL%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言现如今，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。所以，我整理了MySQL优化的几点建议，希望这些优化技巧对您有用，总结不到的，欢迎大家补充。 SQL执行慢的原因 网络速度慢，内存不足，I/O吞吐量小，磁盘空间满了等硬件问题 没有索引或者索引失效 数据表里的数据记录过多 服务器调优及各个参数设置也可能会影响 开发者编写的SQL效率 其他 1、EXPLAIN分析你的SELECT查询很多情况下，使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的，这可以帮你分析你的查询语句，从而或许能尽快的找到优化方法以及潜在的性能问题。具体EXPLAIN的使用以及各个参数的含义，请查阅相关文档即可。 2、SELECT查询必须指明字段名SELECT * 的查询会加很多不必要的消耗（例如CPU、I/O等），同时，也有可能增加了使用覆盖索引。所以SELECT查询时，要求直接在后面指明需要查询的对应字段名。 3、查询一条数据的时候，使用 LIMIT 1减少多余的查询，因为指定limit 1后，查询到一条数据就不再继续查询了，使得EXPLAIN中type列达到const类型，查询语句更优。 4、为搜索的WHERE字段建立索引一般，每个表我们都会设置一个主键，而索引并不一定就是给主键。如果在你的表中，有某个字段你总要会经常用来做WHERE查询搜索，而且是读大于写的，那么，请为其建立索引吧，有兴趣了解更多建立索引的的原则，可以查阅相关资料。 5、千万不要使用 ORDER BY RAND()如果你想随机取数据，也许第一个直接会告诉你，用随机数取，切记，这个时候你必须控制你的大脑在这个方向继续想下去，赶紧停止这种可怕的想法。因为这种查询，对数据库的性能毫无益处（消耗CPU）。更好的方案之一是先找到数据所在的条数N，然后再用LIMIT N, 1这样查询。 6、保证每张表都有一个主键ID我们应该养成一种习惯，每设计新建一张表的时候，都应该为其设计一个ID字段，并让其成为主键，而且最好是INT型（也有使用UUID的），同时设置这个ID字段为自增（AUTO_INCREMENT）的标志。 8、尽可能的使用 NOT NULL不要以为NULL不需要空间，事实是NULL也需要额外的空间，也许，很多有没注意但是遇到过，NULL字段在进行查询比较的时候，是比较麻烦的。当然了，如果你实在是必须需要NULL的话，那没辙，就使用吧，否则的话，就建议使用NOT NULL吧。 8、选择合适的存储引擎在MySQL中有MyISAM和InnoDB两种存储引擎，两者各有利弊，所以我们需要了解两者的差异然后来做出最合适的选择，例如InnoDB支持事务而MyISAM不支持，MyISAM查询比InnoDB快等等；总之，如果你不知道选择什么的话，那就用InnoDB吧。 9、把IP地址存为UNSIGNED INT在遇到需要存储IP地址的时候，很多人的第一想法都会是存储VARCHAR(15)字符串类型的，而不会想到要用INT整型来存储；如果你用整型来存储，只需要4个字节，并且你可以有定长的字段，而且这会为你带来查询上的优势。 10、尽量不要在WHERE查询时对字段进行null值判断我们都知道，档我们对一个字段进行null的判断时候，会比较慢的，这是因为这个判断会导致引擎放弃使用所有已有的索引而进行全表扫描搜索。 11、尽量不要使用%前缀的LIKE模糊查询模糊查询，在日常开发中，我们都会经常遇到，但是我相信很多人都是直接 LIKE &#39;%key_word%&#39; 或者 LIKE &#39;%key_word&#39; 这样搜索的，这两种搜索方式，都会导致索引失效从而进行全表扫描搜索。如果解决上面的这种模糊查询呢，答案就是使用“使用全文索引”，具体的用法有兴趣的可以自己查资料一波。 12、避免在WHERE查询时对字段进行表达式操作例如查询语句SELECT id FROM table WHERE num * 2 = 50;，这样的查询，对字段num做了一个乘2的算数操作，就会导致索引失效。 14、减少不必要的排序排序操作会消耗较多的CPU资源，所以减少不必要的排序可以在缓存命中率高等I/O足够的情况下，会降低SQL的响应时间。 14、建议用JOIN代替子查询有的人会说，JOIN的性能其实也并不是很好呀，但是和子查询比起来还是有很大的性能优势的。具体的，可以了解一下子查询的执行计划相关的问题。 15、避免发生隐式类型转换类型转换主要是指在WHERE子句中出现字段的类型和传入的参数类型不一致的时候发生的类型转换；这是因为如果我们传入的数据类型和字段类型不一致，MySQL可能会对我们传的数据进行类型转换操作，也可能不进行处理而直接交由存储引擎去处理，这样一来，就可能会出现索引无法使用的情况而造成执行计划问题。 16、避免多表查询字段类型不一致在遇到需要多表联合查询的时候，我们设计表结构的时候，尽量保持表与表的关联字段一致，并且都要设置索引。同时，多表连接查询时，尽量把结果集小的表作为驱动表。 17、建议开启查询缓存大多数的MySQL服务器都开启了查询缓存，这是提高性能最有效的方法之一，因为查询缓存由MySQL数据库引擎自动处理，当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表，而直接访问缓存结果了。 18、使用UNION代替临时表UNION查询可以把两条或更多的SELECT查询结果合并到一个查询中，从而不再需要创建临时表来完成。需要注意的是，使用UNION的所有SELECT语句中的字段数目要相同。 19、慎用IN查询IN以及NOT IN查询都要慎重，因为可能会导致全表扫描，而对于连续的数值，能用BETWEEN就不要用IN了。 20、欢迎补充结束语这主要是从查询角度去考虑优化，还有一些分表、分区技术以及读写分离等；以上优化之处，如果说的不到位的地方，请大家谅解，MySQL优化的地方可以有很多处，欢迎提出其他优化建议，谢谢。]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法之二分查找]]></title>
    <url>%2F2018%2F09%2F20%2FPHP%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找的定义 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 算法的要求从上面的定义我们可以知道，满足该算法的要求必须如下两点： 必须采用顺序存储结构。 必须按关键字大小有序排列。 算法的步骤其实，二分查找也还是比较容易理解的，大概就是一分为二，然后两边比较，保留有效区间，继续一分为二查找，直到找到或者超出区间则结束，所以二分查找的基本步骤是： 确定要查找的区间 确定要二分时的参照点 区间内选取二分点 根据二分点的值，综合左右区间情况以及求解的目的，舍去一半无用的区间 继续在有效区间重复上面的步骤 算法源码这里，我主要采用递归和非递归两种方法实现，具体如下： 首先第一种是非递归的算法实现，算法如下： 123456789101112131415161718192021222324252627282930313233/** * 二分查找算法 * @param array $arr 待查找区间 * @param int $number 查找数 * @return int 返回找到的键 */function binary_search($arr, $number) &#123; // 非数组或者数组为空，直接返回-1 if (!is_array($arr) || empty($arr)) &#123; return -1; &#125; // 初始变量值 $len = count($arr); $lower = 0; $high = $len - 1; // 最低点比最高点大就退出 while ($lower &lt;= $high) &#123; // 以中间点作为参照点比较 $middle = intval(($lower + $high) / 2); if ($arr[$middle] &gt; $number) &#123; // 查找数比参照点小，舍去右边 $high = $middle - 1; &#125; else if ($arr[$middle] &lt; $number) &#123; // 查找数比参照点大，舍去左边 $lower = $middle + 1; &#125; else &#123; // 查找数与参照点相等，则找到返回 return $middle; &#125; &#125; // 未找到，返回-1 return -1;&#125; 然后第二种是递归的算法实现，算法如下： 123456789101112131415161718192021222324/** * @param array $arr 待查找区间 * @param int $number 查找数 * @param int $lower 区间最低点 * @param int $high 区间最高点 * @return int */function binary_search_recursion(&amp;$arr, $number, $lower, $high) &#123; // 以区间的中间点作为参照点比较 $middle = intval(($lower + $high) / 2); // 最低点比最高点大就退出 if ($lower &gt; $high) &#123; return -1; &#125; if ($number &gt; $arr[$middle]) &#123; // 查找数比参照点大，舍去左边继续查找 return binary_search_recursion($arr, $number, $middle + 1, $high); &#125; elseif ($number &lt; $arr[$middle]) &#123; // 查找数比参照点小，舍去右边继续查找 return binary_search_recursion($arr, $number, $lower, $middle - 1); &#125; else &#123; return $middle; &#125;&#125; 算法的使用需求是在一个排列好的区间（$arr）中，查找一个数（$number）的所在位置，所以，调用算法查找如下： 123456789// 待查找区间$arr = [1, 3, 7, 9, 11, 57, 63, 99];// 非递归查找66所在的位置$find_key = binary_search($arr, 57);// 递归查找66所在的位置$find_key_r = binary_search_recursion($arr, 57, 0, count($arr));// 输出打印print_r($find_key);print_r($find_key_r); 时间复杂度分析在有序数组中如果用暴力的算法去查找，也就是逐个遍历比较，那么时间复杂度是O(n)；但是，用二分查找后，因为每次可以舍去一半查找区间，所以会将时间复杂度减少到O(logn)，算法更优。 最后又到了无聊的客套话时间，老规律，有问题直接留言，有想法直接说，有错误直接提出来，我都会及时回复的，谢谢。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法之四大基础算法]]></title>
    <url>%2F2018%2F09%2F19%2FPHP%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言虽然工作中，你觉得自己并没有涉及到算法这方面的东西，但是算法是程序的核心，一个程序的好与差，关键是这个程序算法的优劣，所以对于冒泡排序、插入排序、选择排序、快速排序这四种基本算法，我想还是要掌握的。 冒泡排序法 冒泡排序大概的意思是依次比较相邻的两个数，然后根据大小做出排序，直至最后两位数。由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。 冒泡是从前往后冒，所以，每轮比较的次数也是逐渐减少的，最后一个数不用比较，其时间复杂度为O(n²)，算法如下： 123456789101112131415161718192021222324/** * 冒泡排序算法 * @param array $arr * @return array */function bubble_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; // 循环需要冒泡的轮数 for ($i = 1, $len = count($arr); $i &lt; $len; $i++) &#123; // 循环每轮需要比较的次数 for ($j = 0; $j &lt; $len - $i; $j++) &#123; // 大的数，交换位置，往后挪 if ($arr[$j] &gt; $arr[$j + 1]) &#123; $temp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $temp; &#125; &#125; &#125; return $arr;&#125; 选择排序法 选择排序的原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；以此类推，直到所有元素均排序完毕。 选择是每一次从假定一个最小值的位置，然后用假定最小值和后面的值依次比较，找到实际的最小值来放到假定最小值的位置上，其时间复杂度也为O(n²)，算法如下： 123456789101112131415161718192021222324252627282930/** * 选择排序法 * @param array $arr * @return array */function select_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; $len = count($arr); for ($i = 0; $i &lt; $len - 1; $i++) &#123; // 假设最小数的位置 $min = $i; // 用假设的最小数和$i后面的数循环比较，找到实际的最小数 for ($j = $i + 1; $j &lt; $len; $j++) &#123; // 后面的数比假设的最小数小，替换最小数 if ($arr[$min] &gt; $arr[$j]) &#123; $min = $j; &#125; &#125; // 假设的最小数和实际不符，交换位置 if ($min != $i) &#123; $temp = $arr[$min]; $arr[$min] = $arr[$i]; $arr[$i] = $temp; &#125; &#125; return $arr;&#125; 插入排序法 插入排序的原理：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。 插入排序法是先将排序元素的前两个元素排序，然后将第三个元素插入已经排序好的两个元素中，所以这三个元素仍然是从小到大排序，接着将第四个元素插入，重复操作直到所有元素都排序好；其时间复杂度同样为O(n²)，算法如下： 12345678910111213141516171819202122232425/** * 插入排序法 * @param array $arr * @return array */function insert_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; $len = count($arr); for ($i = 1; $i &lt; $len; $i++) &#123; // 当前需要比较的临时数 $tmp = $arr[$i]; // 循环比较临时数所在位置前面的数 for ($j = $i - 1; $j &gt;= 0; $j--) &#123; // 前面的数比临时数大，则交换位置 if ($arr[$j] &gt; $tmp) &#123; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr;&#125; 快速排序法 快速排序法是对冒泡排序的一种改进。他的基本原理是：通过一趟排序将待排记录分割成独立的两部分，其中一部分的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行快速排序，整个排序过程可以递归进行，以达到整个序列有序的目的。 快速排序法是从数列中挑出第一个数（最后一个数）作为基准元素，然后循环所有数，和基准书比较分为左右两列，然后重复这样的步骤继续划分为左右两列，算法如下： 1234567891011121314151617181920212223242526272829303132/** * 快速排序法 * @param array $arr * @return array */function quick_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; // 数组长度为1停止排序 $len = count($arr); if ($len == 1) &#123; return $arr; &#125; // 声明左右两个空数组 $left = $right = []; // 循环遍历，把第一个元素当做基准数 for ($i = 1; $i &lt; $len; $i++) &#123; // 比较当前数的大小，并放入对应的左右数组 if ($arr[$i] &gt; $arr[0]) &#123; $right[] = $arr[$i]; &#125; else &#123; $left[] = $arr[$i]; &#125; &#125; // 递归比较 $left = quick_sort($left); $right = quick_sort($right); // 左右两列以及基准数合并 return array_merge($left, [$arr[0]], $right);&#125; 使用方法声明一个待排序的数组，然后调用对应的排序方法即可得到返回的排序好的数组；说明一下，我这里的排序设计都是递增的，如果需要递减，需要修改一下排序算法的比较替换符就行。 123456// 待排序数组$arr = [1, 4, 5, 9, 3, 8, 6];// 调用排序方法$sort_arr = bubble_sort($arr);// 输出打印print_r($sort_arr); 分析算法通常，对于一个给定的算法，我们要做两项分析：第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，第二步就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。还有我们通常说的：算法优化无非就是以时间换空间，以空间换时间，一般这两者是不可兼得。 结束语实现一个程序，肯定是有多种算法的，大家有其他想说的，都可以留言和我交流，谢谢！如有问题，也欢迎指出，我会及时改正，谢谢！]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法之判断是否是质数]]></title>
    <url>%2F2018%2F09%2F18%2FPHP%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[质数的定义 质数又称素数。一个大于1的自然数，除了1和它自身外，不能整除其他自然数的数叫做质数；否则称为合数。 实现思路循环所有可能的备选数字，然后和中间数以下且大于等于2的整数进行整除比较，如果能够被整数，则肯定不是质数，相反，就是质数。 第一种算法这也是最可能先想到的，也就是直接和备选数的中间数去比较，算法源码如下： 123456789101112131415161718192021222324252627/** * 获取所有的质数 * @param array $arr * @return array */function get_prime_number($arr = []) &#123; // 质数数组 $primeArr = []; // 循环所有备选数 foreach ($arr as $value) &#123; // 备选数和备选数的中间数以下的数字整除比较 for ($i = 2; $i &lt;= floor($value / 2); $i++) &#123; // 能够整除，则不是质数，退出循环 if ($value % $i == 0) &#123; break; &#125; &#125; // 被除数$j比备选数的中间数大的则为质数 // 这样判断的依据： // 假如备选数为质数，则内层的for循环不会break退出，则执行完毕，$i会继续+1，即最后$i = floor($value / 2) + 1 // 假如备选数不为质数，则内层的for循环遇到整除就会break退出，$i不会继续+1，即最后$i &lt;= floor($value / 2) if ($value != 1 &amp;&amp; $i &gt; floor($value / 2)) &#123; $primeArr[] = $value; &#125; &#125; return $primeArr;&#125; 第二种算法认真的来说的话，这也不算是另外一种算法，只是对于第一种的稍微点点优化，及中间最大数的优化，缩小比较范围，算法源码如下： 123456789101112131415161718192021222324252627/** * 获取所有的质数 * @param array $arr * @return array */function get_prime_number($arr = []) &#123; // 质数数组 $primeArr = []; // 循环所有备选数 foreach ($arr as $value) &#123; // 备选数和备选数的中间数以下的数字整除比较 for ($i = 2; $i &lt;= floor($value / $i); $i++) &#123; // 能够整除，则不是质数，退出循环 if ($value % $i == 0) &#123; break; &#125; &#125; // 被除数$j比备选数的中间数大的则为质数 // 这样判断的依据： // 假如备选数为质数，则内层的for循环不会break退出，则执行完毕，$i会继续+1，即最后$i = floor($value / $i) + 1 // 假如备选数不为质数，则内层的for循环遇到整除就会break退出且$i不会继续+1，即最后$i &lt;= floor($value / $i) if ($value != 1 &amp;&amp; $i &gt; floor($value / $i)) &#123; $primeArr[] = $value; &#125; &#125; return $primeArr;&#125; 第三种算法这个的话也是对于第二种的优化，即，直接从完整数组中删除所有不是质数的数即可，算法源码如下： 1234567891011121314151617181920212223242526/** * 获取所有的质数 * @param array $arr * @return array */function get_prime_number_three($arr = []) &#123; // 质数数组 $primeArr = $arr; // 循环所有备选数 foreach ($primeArr as $key =&gt; $value) &#123; if ($value == 1) &#123; unset($primeArr[$key]); continue; &#125; // 备选数和备选数的中间数以下的数字整除比较 for ($i = 2; $i &lt;= floor($value / $i); $i++) &#123; // 能够整除，则不是质数，从数组中删除且退出循环 if ($value % $i == 0) &#123; unset($primeArr[$key]); break; &#125; &#125; &#125; // 重置数组索引返回 return array_values($primeArr);&#125; 使用方法比如，求1-100的所有质数123456// 所有备选数数组$numberArr = range(1, 100, 1);// 获取备选数中的所有质数$primeNumberArr = get_prime_number($numberArr);// 输出打印print_r($primeNumberArr); 又比如，求指定数组中的所有质数123456// 所有备选数数组$numberArr = [11, 22, 33, 66, 77, 3, 8, 10, 99];// 获取备选数中的所有质数$primeNumberArr = get_prime_number($numberArr);// 输出打印print_r($primeNumberArr); 最后如有说的不对的地方，请大家多多谅解，欢迎留言和我沟通、交流，谢谢！]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面试总结]]></title>
    <url>%2F2018%2F09%2F11%2FPHP%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言面试是你进入公司的第一个关卡，如同高考一般，但是面试不是高考，高考只有一次，而面试则可以有N次，只要有合适的面试邀请，你就可以继续尝试，不要害怕失败；假如公司没有选择你，不是你不优秀，只是你不符合他们的要求罢了，结束后总结下面试中不足的地方，及时调整好心态，准备下个面试才是你最正确的做法。 面试准备俗话说：“将军不打没准备的仗”，参加高考也是需要寒窗苦读12年甚至更久，而求职面试呢，也是需要提前准备的，主要分如下几个方面来准备： 自我介绍，这个不用我说了吧，几乎每场面试都会遇到 PHP基础语法和函数 提前准备好怎么在面试官面前表述自己的项目（体现用到的技术与亮点/难点） 简历上自己的列出的专业技能，要看一下相关知识点，因为面试官会从你的这些技能中问你问题 MySQL数据库方面，比如事务处理、索引、锁、查询优化、表结构设计等 PHP进阶方面，例如MVC、OOP、算法、设计模式、redis等 Javascript、Ajax、jQuery等前端知识，会Vue或者Node.js一般会有加分呢 丰富GitHub项目、博客以及自己活跃的社区主页信息等 准备好你的个人简历 …… 技术面试知识点MySQL索引 索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度，从而提高性能，是MySQL查询优化之一。 更多索引相关详见 https://segmentfault.com/a/1190000003072424 MySQL优化现如今，各种大数据、高并发的时代，数据库的操作越来越成为整个架构的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时，我们都需要注意数据操作的性能。而在面试过程中，也是经常会遇到的，所以，无论是面试准备还是日常开发，我们都应该关注这方面的东西。 更多优化方法和技巧详见 https://coolshell.cn/articles/1846.html MySQL事务我们都知道，事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位；所以MySQL事务主要用于处理操作量大，复杂度高的数据。 MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务；一般来说，事务都具备4个特性（ACID）：：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 更多MySQL事务详见 https://www.jianshu.com/p/bcc614524024 MyISAN与InnoDB的区别MyISAN与InnoDB都是MySQL的数据库引擎之一，在5.5版之前MyISAM是MySQL的默认数据库引擎；MyISAN虽然性能极佳，但却有一个缺点：不支持事务处理（transaction），而恰恰相反，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，所以，如果在日常开发中，如果遇到不知道选择哪种表类型的，那么就选择InnoDB吧。 更多MyISAN与InnoDB的的比较详见 https://www.jianshu.com/p/a957b18ba40d HTTP协议 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW: World Wide Web）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据，HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统，他的主要特点是：简单快速、灵活、无连接、无状态、支持B/S及C/S模式等。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 更多有关HTTP协议详见 https://www.jianshu.com/p/80e25cb1d81a TCP/IP协议从字面意义上讲，有人可能会认为TCP/IP是指TCP和IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。他们与TCP或IP的关系紧密，是互联网必不可少的组成部分。TCP/IP一词泛指这些协议，因此，有时也称TCP/IP为网际协议群。 更多内容详见 https://juejin.im/post/5a069b6d51882509e5432656 四大基础算法虽然工作中，你觉得自己并没有涉及到算法这方面的东西，但是算法是程序的核心，一个程序的好与差，关键是这个程序算法的优劣，所以对于冒泡排序、插入排序、选择排序、快速排序这四种基本算法，我想还是要掌握的。 通常，一个需求可以有多种算法实现，所以除了理解算法的实现之外，我们还需要关注算法的执行时间以及性能评估，这样，才能找到最优算法，而时间复杂度和空间复杂度就是衡量一个算法的优劣。 更多算法知识点详见 https://www.jianshu.com/p/a8cd6cbf733d更多时间和空间复杂度详见 https://blog.csdn.net/zolalad/article/details/11848739 二分算法/二分查找这个算法常用于在一个有序数组中查找某个值第一次出现的位置、最后出现的位置、或者是一段区间。用二分法后，由于每次可以去掉一半无用的区间，会将时间复杂度减少到O(logn)，而通常，二分算法可以用递归以及不递归实现，这两种建议都了解下。 二分法的基本做法是：1、确定要查找的区间。2、确定要二分时的参照点。2、区间内选取二分点。3、根据二分点的值，综合左右区间情况以及求解的目的，舍去一半无用的区间。 更多二分算法解析详见 https://juejin.im/entry/585917c661ff4b006cba47cf PHP7的新特性 PHP7将在2015年10月正式发布，PHP7，将会是PHP脚本语言的重大版本更新，同时将带来大幅的性能改进和新的特性，以及改进一些过时功能。该发布版本将会专注在性能加强，源自PHP版本树中的phpng分支。在硅谷公司的ZendCon会议，PHP工具厂商Zend技术官方讨论phpng和PHP7的进度。“（本次升级）真正专注于帮助业界的应用程序显著加强执行速度，再加上，我们在PHP中的其他改进，”Zend的首席执行官安迪特曼斯 （曾参与了PHP语言的持续开发和发展）表示。 PHP7的新特性主要有：标量类型声明、返回值类型声明、null合并运算符、太空船操作符、通过define()定义常量数组、匿名类等。 PHP7新特性详见 http://php.net/manual/zh/migration70.new-features.php Nginx和Php-fpm的工作原理我们知道Nginx (engine x)是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务器。而Php-fpm是FastCGI的实现，并提供了进程管理的功能。因为Nginx不只有处理http请求的功能，还能做反向代理；所以Nginx通过反向代理功能将动态请求转向后端Php-fpm。 更多原理详见 https://segmentfault.com/a/1190000007322358 ThinkPHP5/Lavavel的执行流程分析例如从入口到控制器都干了啥、一个URL请求到达路由这里是怎么再到相应的控制器等，这可能涉及框架的源码分析，这个在面试过程中，我相信有不少人遇到过，具体的我就不多说了，需要在自己多去研究和分析了。 ThinkPHP5/Lavavel的比较大家都知道，ThinkPHP5是国人开发的，各种参考文档都比较全，适合快速入门，而Laravel则是比较优雅的框架，也号称是最艺术的。这两种框架，都有自己很大的用户群体，有网友说：“ThinkPHP5的优势在于好用，Laravel的优势在于装逼。”具体的比较，请大家可以Google或者Baidu查询更多比较详情。 项目的攻坚点/架构攻坚点这个就需要读者结合自己的项目经验进行总结归纳了，主要包括工作中遇到的问题和解决方案，也就是，这个项目中你的特长之处，做的比较好的方面以及攻克的技术难点。 架构的话呢，这个也会有问到的，我就在面试过程中，被遇到过很多次，你可以说一下自己最近这个项目的一个架构就行，后者，说一下你最熟悉的一个项目的架构也行，具体的可以自己查找相关资料深入了解。 Linux知识Linux是开源的、免费的操作系统，稳定性、安全性与并发性得到业界公认，是一个统称，常见的CentOS、Ubuntu、Rethat…… Linux的特点主要有：开源、免费、多线程、多用户、安全性好、对内存和文件管理优越等；面试中，一般会问到一些你对于Linux的命令和用法的熟悉程度，如果你日常开发中，经常用到，那么我相信面试应该也不成问题，但是也还需要多了解一点。 OOP和MVC的理解 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。 PHP面向对象的三大特性是：封装、继承、多态；同时OOP软件的三个目标是：重用性、拓展性、灵活性。所以，采用OOP这种编程思想和技术为编程人员敞开了一扇大门，使其编程的代码更简洁、更易于维护，并且具有更强的可重用性。 MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 关于OOP的更多详见 http://www.runoob.com/php/php-oop.html关于MVC的更多详见 http://www.manongjc.com/article/1864.html 设计模式 在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。其中，常见的设计模式有：工厂模式、单例模式等。 有关设计模式的更多请详见 http://larabase.com/collection/5/post/143 Redis和MemcacheRedis和Memcache都属于内存(memory)键-值(key-value)数据库，在设计和思想上有许多相同之处，功能和应用在很多场合(如分布式缓存服务)也相似。它们都从属于数据库解决方案中的nosql家族，由于两者都将数据存储在内存中，自然而然，它们都是非常理想的缓存实现方案。 Memcache最初是由Brad Fitzpatrick于2003年开发而成。而Redis则由Salvatore Sanfilippo于2009年创建，它本身也从Memcache上吸取借鉴大量宝贵经验教训，被称为“强化版Memcache”。确实，Redis在功能多样性方面要胜过Memcache，虽然强大且更具灵活性，但复杂程度也比Memcache更甚。而Redis和Memcache的不同点主要体现在：数据类型支持不同、内存管理机制不同、数据持久化支持、集群管理的不同等。 有关比较详情查看 https://www.biaodianfu.com/redis-vs-memcached.html 前端技术也许有的人会说，我作为一名后端开发人员，我需要学习前端技术吗？答案是肯定的，不管是对于工作还是自己的职业发展规划，前端技术都是需要学习和掌握的，例如Javascript、Jquery、Ajax都要了解的，如果会Vue或者Node.js等更好。在面试中，偶尔会涉及到一些。 Jsonp跨域的使用和原理PHP处理跨域一般有三种方法：服务器代理、Jsonp、服务器脚本增加支持；有些网站处于安全考虑, 不会设置允许跨域, 而我们又刚好会用到一次跨域请求, 那么, Jsonp就派上用场了。 Jsonp如何实现跨域：由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 其他更多有关Jsonp的用法，可以自行百度。 API的数据安全传输前后端分离的开发方式，我们以接口为标准来进行推动，定义好接口，各自开发自己的功能，最后进行联调整合。无论是开发原生的APP还是webapp还是PC端的软件,只要是前后端分离的模式，就避免不了调用后端提供的接口来进行业务交互，这个时候，数据信息就非常重要了。 我们常用到的尽量保证数据安全的方法主要方式有：使用https、请求签名（防止参数被篡改）、身份确认机制（每次请求都要验证是否合法）、APP中使用ssl pinning防止抓包操作、对所有请求和响应都进行加解密操作等；这里我想说一下，可以了解一下jwt。 什么是JWT https://www.jianshu.com/p/576dbf44b2ae 分析URL的组成部分这个，主要采用PHP函数parse_url()来解析，本函数解析一个URL并返回一个关联数组，包含在URL中出现的各种组成部分，并了解URL的各个组成部分的含义和所在位置；一个URL，一般都包括：协议、域名、端口（web的很多80默认）、文件名、参数等。 有关parse_url的用法和返回值详见 http://www.php.net/manual/zh/function.parse-url.php 人事面试点 你之前所在公司的离职原因 谈谈你对加班的看法 你为什么会选择来我们公司 你未来的职业规划以及发展方向 对自己的一个评价 你的业余爱好，最近在看什么书 对你的经历提出一些问题 你还有什么问题要问我 你在之前，有去过那些公司面试？接下来还约了其他的面试吗 你的期望薪资以及要求 …… 最后这是我结合自己面试过程中，总结的一些经验，希望能帮助到大家，如果有说的不对或者不到位的地方，欢迎指正和交流。在此，祝愿大家都能找到一份满意的工作。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发必备之Git常用基础命令]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E4%B9%8BGit%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言这个Git常用命令的文章，之前在掘金和SegmentFault都有发不过，现在想整理到个人博客中，分享给大家，所以，才在这里重新发布。如有问题，请给我留言沟通，谢谢！ Git是什么？Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个免费、开源的版本控制软件，用于敏捷高效地处理任何或小或大的项目，可以有效、高速的处理从不同的项目版本管理。夸一下说：Git是目前世界上最先进的分布式版本控制系统（PS：Git不是GitHub哦）。 为什么要说Git命令行？在我们日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，掌握常用的一些命令，足够日常开发使用。 Git命令：# 首先，需要远程克隆一个项目 $ git clone [project-url] # 配置开发者的提交信息，包括用户名和邮箱 $ git config –global user.name [your-name] $ git config –global user.email [your-email] # 提交文件到版本控制，两个命令配合使用 $ git add [file-dir] $ git commit -m [comment] # 如果本地没有配置公钥，那么你是不是每次pull或者或者push等操作时，是不是都得需要输入Git账号密码？下面的这组命令，将能够快速的解决这个烦恼 $ git config –global credential.helper store # 拉取远程仓库的代码到本地工作区，一说到要拉取代码，很多人都会想到，git pull，但是我个人非常不喜欢这个命令，使用git fetch也可以，我如下两条命令拉取代码 $ git remote update $git rebase origin/[branch-name] # 拉取代码，肯定会遇到有冲突的情况，这个时候，该怎么办呢？不要慌，有冲突就解决嘛，解决我就不说了，我就说，解决冲突代码后的操作，本地代码冲突解决完毕后，执行以下命令即可，即提交解决冲突文件到工作区，继续rebase $ git add [file-dir] $ git rebase –continue # 当然了，如果你拉取远程代码到本地遇到冲突了，你不想拉取了，想先退回到冲突前，该怎么办？执行下面的命令即可，即取消rebase $ git rebase –abort # 还有一个操作，也许偶尔能用得上，也就是，你rebase错了分支或者你rebase了对的分支，但是也想要会退到rebase之前，该怎么操作呢？下面这条命令很有用， $ git reset –hard ORIG_HEAD # 当然了，除了上面这条命令回退之外，下面的这条命令也可以，显示当前版本最近的几次提交，然后选择回退到某节点 $ git reflog [param] # 推送本地修改的代码到远程仓库，推送成功的前提是你本地的版本必须是最新的，即要与远程仓库的一直才会push成功，否则，请先拉取代码，再执行push操作 $ git push origin HEAD:[branch-name] 结束语如有说的不正确的地方，请指出，相互交流、学习。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现12306火车票自动抢票，并短信和邮件通知]]></title>
    <url>%2F2018%2F08%2F28%2FPython%E5%AE%9E%E7%8E%B012306%E7%81%AB%E8%BD%A6%E7%A5%A8%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8%EF%BC%8C%E5%B9%B6%E7%9F%AD%E4%BF%A1%E5%92%8C%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[前言这个脚本的文章，之前我有发布在掘金和SegmentFault上面过，现在想整理到个人博客中，分享给大家，所以，才在这里重新发布。如有问题，请给我留言沟通，谢谢！ 脚本实现及实践最近在学Python，所以用Python写了这个12306抢票脚本，分享出来，与大家共同交流和学习，有不对的地方，请大家多多指正。话不多说，进入正题： 这个脚本目前只能刷一趟车的，人数可以是多个，支持选取作为类型等。实现思路是splinter.browser模拟浏览器登陆和操作，由于12306的验证码不好自动识别，所以，验证码需要用户进行手动识别，并进行登陆操作，之后的事情，就交由脚本来操作就可以了，下面是我测试时候的一些截图： 第一步：如下图，首先输入抢票基本信息 第二步：然后进入登录页，需要手动输入验证码，并点击登陆操作 第三步：登陆后，自动进入到抢票页面，如下图这样的 最后：就是坐等刷票结果就好了，如下图这样，就说是刷票成功了，刷到票后，会进行短信和邮件的通知，请记得及时前往12306进行支付，不然就白抢了。 运行环境Python运行环境：python3.6用到的模块：re、splinter、time、sys、httplib2、urllib、smtplib、email未安装的模块，请使用pip instatll进行安装，例如：pip install splinter如下代码是这个脚本所有用到的模块引入： 12345678import refrom splinter.browser import Browserfrom time import sleepimport sysimport httplib2from urllib import parseimport smtplibfrom email.mime.text import MIMEText 准备城市名COOKIE刷票前信息准备，我主要说一下始发站和目的地的cookie值获取，因为输入城市的时候，需要通过cookie值，cookie值可以通过12306官网，然后在F12（相信所有的coder都知道这个吧）的network里面的查询请求cookie中可以看到，在请求的header里面可以找到，_jc_save_fromStation值是出发站的cookie，_jc_save_toStation的值是目的地的cookie，然后加入到代码里的城市的cookie字典city_list里即可，键是城市的首字母，值是cookie值的形式。 模拟登陆操作抢票，肯定需要先登录，我这里模拟的登录操作，会自动填充12306的账号名和密码，当然，你也可以在打开的浏览器中修改账号和密码，实现的关键代码如下： 123456789101112def do_login(self): """登录功能实现，手动识别验证码进行登录""" self.driver.visit(self.login_url) sleep(1) self.driver.fill('loginUserDTO.user_name', self.user_name) self.driver.fill('userDTO.password', self.password) print('请输入验证码……') while True: if self.driver.url != self.init_my_url: sleep(1) else: break 登录之后，就是控制刷票的各种操作处理了，这里，我就不贴代码了，因为代码比较多，别担心，在最后，我会贴出完整的代码的。 短信和邮件通知当刷票成功后，我会进行短信和邮件的双重通知，当然，这里短信通知的平台，就看你用那个具体来修改代码了，我用的是互亿无线的体验版的免费短信通知接口；发送邮件模块我用的是smtplib，发送邮件服务器用的是163邮箱，如果用163邮箱的话，你还没有设置客户端授权密码，记得先设置客户端授权密码就好了，挺方便的。以下是主要实现代码： 1234567891011121314151617181920212223242526272829303132333435def send_sms(self, mobile, sms_info): """发送手机通知短信，用的是-互亿无线-的测试短信""" host = "106.ihuyi.com" sms_send_uri = "/webservice/sms.php?method=Submit" account = "C59782899" pass_word = "19d4d9c0796532c7328e8b82e2812655" params = parse.urlencode( &#123;'account': account, 'password': pass_word, 'content': sms_info, 'mobile': mobile, 'format': 'json'&#125; ) headers = &#123;"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"&#125; conn = httplib2.HTTPConnectionWithTimeout(host, port=80, timeout=30) conn.request("POST", sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() conn.close() return response_strdef send_mail(self, receiver_address, content): """发送邮件通知""" # 连接邮箱服务器信息 host = 'smtp.163.com' port = 25 sender = 'xxxxxx@163.com' # 你的发件邮箱号码 pwd = '******' # 不是登陆密码，是客户端授权密码 # 发件信息 receiver = receiver_address body = '&lt;h2&gt;温馨提醒：&lt;/h2&gt;&lt;p&gt;' + content + '&lt;/p&gt;' msg = MIMEText(body, 'html', _charset="utf-8") msg['subject'] = '抢票成功通知！' msg['from'] = sender msg['to'] = receiver s = smtplib.SMTP(host, port) # 开始登陆邮箱，并发送邮件 s.login(sender, pwd) s.sendmail(sender, receiver, msg.as_string()) 源码分享说了那么多，感觉都是说了好多废话啊，哈哈，不好意思，耽误大家时间来看我瞎扯了，我贴上大家最关心的源码，请接码，大家在尝试运行过程中，有任何问题，可以给我留言或者私信我，我看到都会及时回复大家的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#!/usr/bin/env python# -*- coding: utf-8 -*-"""通过splinter刷12306火车票可以自动填充账号密码，同时，在登录时，也可以修改账号密码然后手动识别验证码，并登陆，接下来的事情，交由脚本来做了，静静的等待抢票结果就好（刷票过程中，浏览器不可关闭）author: cuizytime: 2018-05-30"""import refrom splinter.browser import Browserfrom time import sleepimport sysimport httplib2from urllib import parseimport smtplibfrom email.mime.text import MIMETextclass BrushTicket(object): """买票类及实现方法""" def __init__(self, user_name, password, passengers, from_time, from_station, to_station, number, seat_type, receiver_mobile, receiver_email): """定义实例属性，初始化""" # 1206账号密码 self.user_name = user_name self.password = password # 乘客姓名 self.passengers = passengers # 起始站和终点站 self.from_station = from_station self.to_station = to_station # 乘车日期 self.from_time = from_time # 车次编号 self.number = number.capitalize() # 座位类型所在td位置 if seat_type == '商务座特等座': seat_type_index = 1 seat_type_value = 9 elif seat_type == '一等座': seat_type_index = 2 seat_type_value = 'M' elif seat_type == '二等座': seat_type_index = 3 seat_type_value = 0 elif seat_type == '高级软卧': seat_type_index = 4 seat_type_value = 6 elif seat_type == '软卧': seat_type_index = 5 seat_type_value = 4 elif seat_type == '动卧': seat_type_index = 6 seat_type_value = 'F' elif seat_type == '硬卧': seat_type_index = 7 seat_type_value = 3 elif seat_type == '软座': seat_type_index = 8 seat_type_value = 2 elif seat_type == '硬座': seat_type_index = 9 seat_type_value = 1 elif seat_type == '无座': seat_type_index = 10 seat_type_value = 1 elif seat_type == '其他': seat_type_index = 11 seat_type_value = 1 else: seat_type_index = 7 seat_type_value = 3 self.seat_type_index = seat_type_index self.seat_type_value = seat_type_value # 通知信息 self.receiver_mobile = receiver_mobile self.receiver_email = receiver_email # 主要页面网址 self.login_url = 'https://kyfw.12306.cn/otn/login/init' self.init_my_url = 'https://kyfw.12306.cn/otn/index/initMy12306' self.ticket_url = 'https://kyfw.12306.cn/otn/leftTicket/init' # 浏览器驱动信息，驱动下载页：https://sites.google.com/a/chromium.org/chromedriver/downloads self.driver_name = 'chrome' self.executable_path = 'C:\\Users\cuizy\AppData\Local\Programs\Python\Python36\Scripts\chromedriver.exe' def do_login(self): """登录功能实现，手动识别验证码进行登录""" self.driver.visit(self.login_url) sleep(1) self.driver.fill('loginUserDTO.user_name', self.user_name) self.driver.fill('userDTO.password', self.password) print('请输入验证码……') while True: if self.driver.url != self.init_my_url: sleep(1) else: break def start_brush(self): """买票功能实现""" self.driver = Browser(driver_name=self.driver_name, executable_path=self.executable_path) # 浏览器窗口的大小 self.driver.driver.set_window_size(900, 700) self.do_login() self.driver.visit(self.ticket_url) try: print('开始刷票……') # 加载车票查询信息 self.driver.cookies.add(&#123;"_jc_save_fromStation": self.from_station&#125;) self.driver.cookies.add(&#123;"_jc_save_toStation": self.to_station&#125;) self.driver.cookies.add(&#123;"_jc_save_fromDate": self.from_time&#125;) self.driver.reload() count = 0 while self.driver.url.split('?')[0] == self.ticket_url: self.driver.find_by_text('查询').click() sleep(1) count += 1 print('第%d次点击查询……' % count) try: car_no_location = self.driver.find_by_id("queryLeftTable")[0].find_by_text(self.number)[1] current_tr = car_no_location.find_by_xpath("./../../../../..") if current_tr.find_by_tag('td')[self.seat_type_index].text == '--': print('无此座位类型出售，已结束当前刷票，请重新开启！') sys.exit(1) elif current_tr.find_by_tag('td')[self.seat_type_index].text == '无': print('无票，继续尝试……') else: # 有票，尝试预订 print('刷到票了（余票数：' + str(current_tr.find_by_tag('td')[self.seat_type_index].text) + '），开始尝试预订……') current_tr.find_by_css('td.no-br&gt;a')[0].click() sleep(1) key_value = 1 for p in self.passengers: # 选择用户 print('开始选择用户……') self.driver.find_by_text(p).last.click() # 选择座位类型 print('开始选择席别……') if self.seat_type_value != 0: seat_select = self.driver.find_by_id("seatType_" + str(key_value))[0] seat_select.find_by_xpath("//option[@value='" + str(self.seat_type_value) + "']")[0].click() key_value += 1 sleep(0.5) if p[-1] == ')': self.driver.find_by_id('dialog_xsertcj_ok').click() print('正在提交订单……') self.driver.find_by_id('submitOrder_id').click() sleep(2) # 查看放回结果是否正常 submit_false_info = self.driver.find_by_id('orderResultInfo_id')[0].text if submit_false_info != '': print(submit_false_info) self.driver.find_by_id('qr_closeTranforDialog_id').click() sleep(0.2) self.driver.find_by_id('preStep_id').click() sleep(0.3) continue print('正在确认订单……') self.driver.find_by_id('qr_submit_id').click() print('预订成功，请及时前往支付……') # 发送通知信息 self.send_mail(self.receiver_email, '恭喜您，抢到票了，请及时前往12306支付订单！') self.send_sms(self.receiver_mobile, '您的验证码是：8888。请不要把验证码泄露给其他人。') except Exception as error_info: print(error_info) except Exception as error_info: print(error_info) def send_sms(self, mobile, sms_info): """发送手机通知短信，用的是-互亿无线-的测试短信""" host = "106.ihuyi.com" sms_send_uri = "/webservice/sms.php?method=Submit" account = "C59782899" pass_word = "19d4d9c0796532c7328e8b82e2812655" params = parse.urlencode( &#123;'account': account, 'password': pass_word, 'content': sms_info, 'mobile': mobile, 'format': 'json'&#125; ) headers = &#123;"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"&#125; conn = httplib2.HTTPConnectionWithTimeout(host, port=80, timeout=30) conn.request("POST", sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() conn.close() return response_str def send_mail(self, receiver_address, content): """发送邮件通知""" # 连接邮箱服务器信息 host = 'smtp.163.com' port = 25 sender = 'gxcuizy@163.com' # 你的发件邮箱号码 pwd = 'CUIzy9118' # 不是登陆密码，是客户端授权密码 # 发件信息 receiver = receiver_address body = '&lt;h2&gt;温馨提醒：&lt;/h2&gt;&lt;p&gt;' + content + '&lt;/p&gt;' msg = MIMEText(body, 'html', _charset="utf-8") msg['subject'] = '抢票成功通知！' msg['from'] = sender msg['to'] = receiver s = smtplib.SMTP(host, port) # 开始登陆邮箱，并发送邮件 s.login(sender, pwd) s.sendmail(sender, receiver, msg.as_string())if __name__ == '__main__': # 12306用户名 user_name = input('请输入12306用户名：') while user_name == '': user_name = input('12306用户名不能为空，请重新输入：') # 12306登陆密码 password = input('请输入12306登陆密码：') while password == '': password = input('12306登陆密码不能为空，请重新输入：') # 乘客姓名 passengers_input = input('请输入乘车人姓名，多人用英文逗号“,”连接，（例如单人“张三”或者多人“张三,李四”）：') passengers = passengers_input.split(",") while passengers_input == '' or len(passengers) &gt; 4: print('乘车人最少1位，最多4位！') passengers_input = input('请重新输入乘车人姓名，多人用英文逗号“,”连接，（例如单人“张三”或者多人“张三,李四”）：') passengers = passengers_input.split(",") # 乘车日期 from_time = input('请输入乘车日期（例如“2018-08-08”）：') date_pattern = re.compile(r'^\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;$') while from_time == '' or re.findall(date_pattern, from_time) == []: from_time = input('乘车日期不能为空或者时间格式不正确，请重新输入：') # 城市cookie字典 city_list = &#123; 'bj': '%u5317%u4EAC%2CBJP', # 北京 'hd': '%u5929%u6D25%2CTJP', # 邯郸 'nn': '%u5357%u5B81%2CNNZ', # 南宁 'wh': '%u6B66%u6C49%2CWHN', # 武汉 'cs': '%u957F%u6C99%2CCSQ', # 长沙 'ty': '%u592A%u539F%2CTYV', # 太原 'yc': '%u8FD0%u57CE%2CYNV', # 运城 'gzn': '%u5E7F%u5DDE%u5357%2CIZQ', # 广州南 'wzn': '%u68A7%u5DDE%u5357%2CWBZ', # 梧州南 &#125; # 出发站 from_input = input('请输入出发站，只需要输入首字母就行（例如北京“bj”）：') while from_input not in city_list.keys(): from_input = input('出发站不能为空或不支持当前出发站（如有需要，请联系管理员！），请重新输入：') from_station = city_list[from_input] # 终点站 to_input = input('请输入终点站，只需要输入首字母就行（例如北京“bj”）：') while to_input not in city_list.keys(): to_input = input('终点站不能为空或不支持当前终点站（如有需要，请联系管理员！），请重新输入：') to_station = city_list[to_input] # 车次编号 number = input('请输入车次号（例如“G110”）：') while number == '': number = input('车次号不能为空，请重新输入：') # 座位类型 seat_type = input('请输入座位类型（例如“软卧”）：') while seat_type == '': seat_type = input('座位类型不能为空，请重新输入：') # 抢票成功，通知该手机号码 receiver_mobile = input('请预留一个手机号码，方便抢到票后进行通知（例如：18888888888）：') mobile_pattern = re.compile(r'^1&#123;1&#125;\d&#123;10&#125;$') while receiver_mobile == '' or re.findall(mobile_pattern, receiver_mobile) == []: receiver_mobile = input('预留手机号码不能为空或者格式不正确，请重新输入：') receiver_email = input('请预留一个邮箱，方便抢到票后进行通知（例如：test@163.com）：') while receiver_email == '': receiver_email = input('预留邮箱不能为空，请重新输入：') # 开始抢票 ticket = BrushTicket(user_name, password, passengers, from_time, from_station, to_station, number, seat_type, receiver_mobile, receiver_email) ticket.start_brush() 另外，该脚本，我也放到了GitHub上面，有兴趣的可以前往查看。源码地址：https://github.com/gxcuizy/Python/tree/master/12306qiangpiao]]></content>
      <tags>
        <tag>Python</tag>
        <tag>12306</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Python爬取国家统计局省市区三级地址库（支持MySQL和JSON格式）]]></title>
    <url>%2F2018%2F08%2F27%2F%E9%80%9A%E8%BF%87Python%E7%88%AC%E5%8F%96%E4%B8%89%E7%BA%A7%E5%9F%8E%E5%B8%82%E5%9C%B0%E5%9D%80%E5%BA%93%EF%BC%88%E6%94%AF%E6%8C%81MySQL%E5%92%8CJSON%E6%A0%BC%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据来源通过Python脚本，自动抓取国家统计局最新的中国省市区三级城市信息，目前抓取的最新数据为2017年统计用区划代码和城乡划分代码(截止2017年10月31日)，我会关注，时刻保持更新。 数据格式目前支持MySQL格式和JSON格式，其中MySQL的有两个版本，分别为三张表和一张表的，即三张表的为省市区三张表，而一张表的则把省市区三级城市通过关联关系都存在一张表中，可以根据自己的需求进行选择，如果有其他格式需求，可以联系我或者自己修改脚本。 脚本目录结构12345678├── json # 存储JSON数据格式├── mysql # 存储三张表的数据格式├── mysql_v2 # 存储一张表的数据格式├── city_to_json.py # 抓取JSON数据格式的脚本├── city_mysql.py # 抓取三张表的数据格式的脚本├── city_to_mysql_v2.py # 抓取一张表的数据格式的考平贝母├── mysql_init.sql # 存储三张表的数据的表结构├── mysql_v2_init # 存储一张表的数据的表结构 如有需要，直接下载后缀为json或者sql的文件即可直接使用，也可以根据对应的python脚本重新生成相应的省市区三级地址库数据。 抓取数据方法这里主要使用requests、beautifulsoup4以及json这三个模块，通过requests发送url页面请求，然后BeautifulSoup分析请求到的页面信息，抓取有效数据，通过json模块，读取以及存储json格式的数据，而mysql的数据则直接通过文件的读写操作即可。 源码分享这个爬虫脚本比较易读，而且碍于文章篇幅问题，所以，我这里就不贴源码了，直接放到交友网站GitHub上了，有兴趣的可以前往查看。 源码以及数据地址：https://github.com/gxcuizy/Python/tree/master/%E7%9C%81%E5%B8%82%E5%8C%BA%E4%B8%89%E7%BA%A7%E5%9C%B0%E5%9D%80%E5%BA%93]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python如何生成windows可执行的exe文件]]></title>
    <url>%2F2018%2F08%2F21%2FPython%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90windows%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84exe%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为什么要生成可执行文件 不需要安装对应的编程环境 可以将你的应用闭源 用户可以方便、快捷的直接使用 打包工具 pyinstaller 安装pyinstaller如果你的网络稳定，通常直接使用下面的命令安装即可：1pip install pyinstaller 当然了，你也可以下载pyinstaller源码包，然后进入包目录执行下面的命令，同样可以安装（前提是需要安装setuptools）：1python setup.py install 安装过程如下图所示 检查pyinstaller安装成功与否：只需要执行如下命令其中一个即可： 12pyinstaller --versionpyinstaller -v 如果出现如下界面，就说明是安装成功了 pyinstaller参数作用 -F 表示生成单个可执行文件 -D –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项） -w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧 -c –console, –nowindowed 使用控制台，无界面(默认) -p 表示你自己自定义需要加载的类路径，一般情况下用不到 -i 表示可执行文件的图标 其他参数，可以通过pyinstaller --help查看 开始打包进入python需要打包的脚本所在目录，然后执行下面的命令即可： 1python -F -i favicon.ico nhdz.py 执行过程如下图所示： 打包结果打包完成后，进入到当前目录下，会发现多了__pycache__、build、dist、nhdz.spec这四个文件夹或者文件，其中打包好的exe应用在dist目录下面，进入即可看到，可以把他拷贝到其他地方直接使用，如下图所示，是打包完成后的目录： 执行exe应用因为是exe应用，是可执行文件了，所以直接双击运行即可，运行效果如下图所示： 到这里，exe文件就已经生算是打包完成，并且可以运行了，如果你想在其他平台运行，只需要拷贝dist下面的文件即可 ICO图标制作前面需要用到ICO图标，大家可以网上搜索“ICO 在线生成”，可以直接点击ICO图标制作在上面制作、然后保存也行 最后大家有什么疑问或者想法，都可以直接和我交流，谢谢！]]></content>
      <tags>
        <tag>Python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新浪微博API生成短链接]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9AAPI%E7%94%9F%E6%88%90%E7%9F%AD%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[什么是短链接 短链接，通俗来说，就是将长的URL网址，通过程序计算等方式，转换为简短的网址字符串。 短链接服务国内各大微博都推出了自己的短链接服务。例如新浪微博、腾讯微博等。 为什么选用新浪微博API 新浪微博短链接API是开放的 新浪微博短链接API不需要用户登录 文档查询链接 short_url/shorten接口地址 网上的一些公开的AppKey 新浪微博短链接在线生成 使用方法拿到自己的AppKey后，替换类的成员属性$appKey的值即可，如下这样的，$shortUrl是API请求地址 1234// APPkey，我在网上找的（https://fengmk2.com/blog/appkey.html），可以自己申请protected $appKey = '569452181';// 转短连接API地址protected $shortUrl = 'https://api.weibo.com/2/short_url/shorten.json?'; 其他的，基本不需要配置，直接实例化类ShortLink，然后调用方法getShortUrl即可，需要说明的是长链接URL数组$longUrl里的值可以传多个值 当然了，为了方便，我写为一个类，可以根据自己的需要，进行调整，满足自己的需求即可。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php/** * 通过新浪微博API，生成短链接，支持一次性转多个长链接 * Class shortClass * @time 2018-08-14 * @author gxcuizy */Class ShortLink &#123; // APPkey，我在网上找的（https://fengmk2.com/blog/appkey.html），可以自己申请 protected $appKey = '569452181'; // 转短连接API地址 protected $shortUrl = 'https://api.weibo.com/2/short_url/shorten.json?'; /** * 生成短链接 * @param array $longUrl 长链接数组 * @return array 返回短连接数据 */ public function getShortUrl($longUrl = []) &#123; $code = true; $msg = '请求成功！'; $result = []; // 长链接数组为空，不处理 if (empty($longUrl)) &#123; $code = false; $msg = '长链接数据不能为空'; return ['code' =&gt; $code, 'msg' =&gt; $msg, 'result' =&gt; $result]; &#125; // 拼接请求URL $longUrlStr = $this-&gt;_getLongUrl($longUrl); $shortUrl = $this-&gt;shortUrl; $appKey = $this-&gt;appKey; $param = 'source=' . $appKey . '&amp;' . $longUrlStr; $curlUrl = $shortUrl . $param; // 发送CURL请求 $result = $this-&gt;_sendCurl($curlUrl); return ['code' =&gt; $code, 'msg' =&gt; $msg, 'result' =&gt; $result]; &#125; /** * 获取请求URL字符串 * @param array $longUrl 长链接数组 * @return string 长链接URL字符串 */ private function _getLongUrl($longUrl = []) &#123; $str = ''; foreach ($longUrl as $url) &#123; $str .= ('url_long=' . $url . '&amp;'); &#125; $newStr = substr($str, 0, strlen($str) - 1); return $newStr; &#125; /** * 发送CURL请求（GET） * @param string $curlUrl 请求地址 * @return array 返回信息 */ private function _sendCurl($curlUrl) &#123; // 初始化 $ch = curl_init(); // 设置选项，包括URL curl_setopt($ch, CURLOPT_URL, $curlUrl); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); // 执行并获取HTML文档内容 $output = curl_exec($ch); // 释放curl句柄 curl_close($ch); // Json数据转为数组 $result = json_decode($output, true); return $result; &#125;&#125;// 实例化对象$shortObj = new ShortLink();// 多个连接可以直接放到数组中，类似$longUrl = ['url1', 'url2', ……]$longUrl = ['http://blog.y0701.com/index.html'];// 开始转长链接为短链接$result = $shortObj-&gt;getShortUrl($longUrl);print_r($result); 结束语上面说到的网上查找得到的一些AppKey，因为来源不明，所以，不建议用于生产环境，需要用于生产环境的话，建议直接在新浪微博开发者平台里创建自己的应用就行。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法和入门]]></title>
    <url>%2F2018%2F08%2F10%2FMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[关于Markdown Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 谁创造了Markdown它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于前几年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：计算机程序员、企业家、作家、政治组织者和互联网黑客主义者；而百度百科则比较简单和含蓄，对他的介绍直接是：年少成名的计算机天才。老实说，他有着足以让你跪拜的人生经历。 为什么要使用Markdown 它基于纯文本，方便修改和共享 几乎可以在所有的文本编辑器中编写 跨平台使用 越来越多的网站支持Markdown 很容易转换为 HTML 文档或其他格式 摆脱Word（他的排版和阅读，要比Word体验好太多了） 适合用来编写文档、记录笔记、撰写文章 …… Markdown基础语法标题Markdown的标题，主要使用#，可表示1-6级标题，如下： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 段落与换行 段落的前后必须是空行，空行指的是行内什么都没有，或者只有空白符（空格或制表符） 如果需要在段落内换行，可以在前一行的末尾加入至少两个空格，然后换行继续写其它的内容 引用Markdown使用邮件风格的&gt;作为块引用。如果你熟悉邮件中的块引用，你也就知道如何在Markdown里创建一个块引用。在每一行前放一个 &gt; 最好 但是，Markdown允许你懒一些,尽在每个段落的开头放一个 &gt;，如下这样的：123&gt; 这是引用测试 这就是应用测试 这真的是引用测试 还可以嵌套引用，即在前一个引用的基础上再加一个 &gt; 即可，如下：123&gt; 这是引用测试 &gt;&gt; 这是嵌套引用测试&gt;&gt;&gt; 这是嵌套引用测试的嵌套 列表无序列表无序列表是使用.（点）、+（加号）、或-（减号）的符号来标记，需要注意的是标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行，例如：123- 这是无序列表- 这是无序列表- 这是无序列表 有序列表有序列表的标记方式是将上述的无序列表的符号换成数字，并辅以.（点）来标记，同时，提醒一下：数字的序列并不会影响生成的列表序列，无论你的序列是什么排的，结果仍然推荐按照自然顺序（1,2,3…）来编写，例如：1231. 这是有序列表2. 这是有序列表4. 这是有序列表 嵌套列表可以多层嵌套，标识符号不变，同上，需要说明的是无序列表和有序列表可以随意相互嵌套，同时，子列表前必须有相对于父列表两个以上空格的缩进，例如：12341. 有序列表 - 无序列表2. 有序列表 * 无序列表 代码代码块代码块可以使用三个 `（ ` 是Tab 键上边、数字1键左侧的那个按键）符号作为标识，即```，开头和结束都要，并且独占一行，例如： ```$str = ‘Hello World’;echo $str;``` 行内代码也可以通过 `来插入行内代码，建议使用一个`就行，例如： `echo ‘Hello World’` 分隔线可以在一行中使用三个或更多的 *（星）、-（减号） 或 _（下划线） 来添加一条分隔线，例如：12*************************************************# 上面是一条分割线 超链接超链接可以由两种形式生成：行内式和参考式 行内式行内式的写法如下：1[链接文字描述](实际超链接URL) 来个行内式的例子吧，如下： 1[博客地址](http://blog.y0701.com) 真实效果为： 博客地址 参考式参考式的写法如下： 1[链接文字描述][实际超链接锚点名] 继续来个参考式的例子吧，如下： 12[博客地址][blog_url] [blog_url]:http://blog.y0701.com 真实效果为： 博客地址 自动连接使用一对尖括号 &lt;&gt; 包括的 URL 或邮箱地址，即可被自动转换为超链接，例如： 1&lt;http://blog.y0701.com&gt; 上面的效果为： http://blog.y0701.com 图片插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个!（英文感叹号）。插入图片的方式也分为行内式和参考式两种 行内式行内式的用法和效果如下： 1![img](https://avatars3.githubusercontent.com/u/25812349?s=400&amp;v=4) 参考式行内式的用法和效果如下： 12![img][img_url] [img_url]:https://avatars3.githubusercontent.com/u/25812349?s=400&amp;v=4 强调 使用一对（一颗星） 或一对（一个下划线） _ _ 包括的文本来标识斜体，例如： 1这句话的 *斜体* 字都是 _斜体_ 的 效果为： 这句话的 斜体 字都是 _斜体_ 的 使用一对（两颗星） 或一对（两个下划线） 包括的文本来标识粗体，例如： 1这句话的 **粗体** 字都是 __粗体__ 的 效果为： 这句话的 粗体 字都是 粗体 的 使用一对（三颗星） 或一对（三个下划线） _ _ 包括的文本来标识斜体且加粗，例如： 1这句话的 ***粗斜体*** 字都是 ___粗斜体___ 的 效果为： 这句话的 粗体 字都是 _粗体_ 的 使用一对（两个波浪线） ~~ ~~ 包括的文本来标识删除，例如： 1这句话的 ~~删除~~ 字都是 ~~删除~~ 的 效果为： 这句话的 删除 字都是 删除 的 需要说明的是，用来包括文本的 或 _ 内侧不能有空白，否则 和 _ 将不会被正确的转换，具体的场景和效果，有兴趣的大家可以自己尝试 最后再说一遍：*、**、***、_、__、__\和~~都必须成对使用 字符转义反斜线（\）用于插入在Markdown语法中具有转义作用的字符，例如： 1这句话的 \*斜体\* 字不会是 \_斜体\_ 其效果为：这句话的 *斜体* 字不会是 _斜体_ Markdown完美支持Html的写法我们知道Markdown不支持指定图片的显示大小，只会按照百分百显示，那么这个时候，实在有必要的话，可以通过直接插入\&lt;img/>标签来指定相关属性，用法和效果如下： 1&lt;img src="https://avatars3.githubusercontent.com/u/25812349?s=400&amp;v=4" alt="这是头像" title="这是头像" width="50%" height="50%" /&gt; 其他HTML标签在Markdown里的用法和\&lt;img/>类似，就像在HTML在那样一模一样的用法即可 Markdown的扩展用法Markdown还有支持很多扩展的语法，这里就不说了，关于其它扩展语法可参见具体工具以及文档的相关使用说明即可 结束语这仅是一些Markdown的基础语法，如有说的不对的地方，欢迎大家指正，我会及时改正，谢谢。]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python通过跳板机连接远程MySQL]]></title>
    <url>%2F2018%2F08%2F10%2FPython%E9%80%9A%E8%BF%87%E8%B7%B3%E6%9D%BF%E6%9C%BA%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8BMySQL%2F</url>
    <content type="text"><![CDATA[工具直接跳板机连接远程MySQL数据库一般公司的数据库在一个远程服务器里，而这个服务器需要链接跳板机才可以访问，而通过远程桌面或云桌面才可以链接跳板机，说明访问数据库是需要一定的权限的（很多公司也不会让你通过本机就可以获取内部数据）这就有个问题了，也就是你不可能在本机直接去访问数据库，这个时候，就需要一些数据库管理工具，例如常用的Navicat、SQLyog等，都是可以的，下面是我Navicat的一些配置（打码部分为配置信息）： SSH连接配置信息 MySQL连接属性常规信息 Python连接安装sshtunnelPython连接的话，得借助sshtunnel模块，这个模块是第三方的模块，所以得先安装，安装方式如下，直接命令行安装就行。 1pip insall sshtunnel 基本配置说明1234567891011121314151617# 跳板机SSH连接with SSHTunnelForwarder( ('192.168.0.1', 22), ssh_username="test", ssh_pkey="test.pem", remote_bind_address=('*************mysql.rds.aliyuncs.com', 3306)) as tunnel: # 数据库连接配置，host默认127.0.0.1不用修改 conn = pymysql.connect( host='127.0.0.1', port=tunnel.local_bind_port, user='root', password='root', db='test', charset='utf8', cursorclass=pymysql.cursors.DictCursor ) 从上面代码可以看到，跳板机的SSH配置信息，192.168.0.1为服务器IP地址，ssh_username为用户名，ssh_pkey为本机私钥存放位置，remote_bind_address为跳板机地址，user为mysql连接用户名，passport为密码，db就是连接的数据库名了，其他的不用配置了，发现连接不对的，就再核对一些配置信息，连接完毕，一定记得关闭连接。 完整源码分享123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-"""通过跳板机，连接远程mysql数据库author: gxcuizytime: 2018-08-10"""import pymysqlfrom sshtunnel import SSHTunnelForwarder# 程序主入口if __name__ == "__main__": # 跳板机SSH连接 with SSHTunnelForwarder( ('192.168.0.1', 22), ssh_username="test", ssh_pkey="test.pem", remote_bind_address=('*************mysql.rds.aliyuncs.com', 3306) ) as tunnel: # 数据库连接配置，host默认127.0.0.1不用修改 conn = pymysql.connect( host='127.0.0.1', port=tunnel.local_bind_port, user='root', password='root', db='test', charset='utf8', cursorclass=pymysql.cursors.DictCursor ) # 获取游标 cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) # 查询数据库，查询一条数据，其他CURD操作类似 sql = "SELECT name FROM table_name WHERE id = '%s'" prams = ('1',) cursor.execute(sql % prams) info = cursor.fetchone() print(info) # 关闭连接 cursor.close() conn.close() 结束语Python可以做很多事情，大家有兴趣的话，可以一起研究和讨论，如有疑问，可以留言或者直接联系我，谢谢。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python下载网易云歌曲（版权限制的怎么播放和下载呢？）]]></title>
    <url>%2F2018%2F08%2F08%2FPython%E4%B8%8B%E8%BD%BD%E7%BD%91%E6%98%93%E4%BA%91%E6%AD%8C%E6%9B%B2%EF%BC%88%E7%89%88%E6%9D%83%E9%99%90%E5%88%B6%E7%9A%84%E6%80%8E%E4%B9%88%E6%92%AD%E6%94%BE%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%91%A2%EF%BC%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[为什么要这样下载网易云音乐，我相信大多数人都用过，我个人觉得非常好用，也一直在用，有的时候，我们搜索一些网易歌曲，发现播放不了，甚至下载不了，因为提示“版权方要求，当前歌曲仅限开通音乐包使用”（见下图），也就是，需要购买才能够下载以及播放，有没有办法不花钱就能播放和下载这首歌曲呢？我研究了一下，还没发现呢，哈哈哈哈，往下看，你会发现惊喜的…… 怎么查找版权限制不让下载和播放的音乐初探network请求信息首先，我想到的是打开F12，查看所有的network请求，一个一个的查看请求返回信息，突然发现了惊喜，如下图所示： 那个请求返回的url，我想应该就是音乐的URL源地址，但是，我通过Python脚本下载这个音乐下来后发现，和我想象的有点不一样，因为这个url确实是音乐的源地址，但是并不是我需要的，因为这个url是当前播放音乐的源地址，然后，我继续点击其他按钮，当我点击播放音乐按钮的时候，有一个detail的请求，里面返回了很多信息，如下图所示： 深入查看network请求信息我研究了一下这些返回信息，发现并没有找到需要的音乐url源地址，然后只能继续在network里面找，刚开始，我只是找的XHR的请求，然后我想着，查找All的请求试试，因为，All请求里，可以包含所有的资源请求，包括图片以及文件资源等，也许会有惊喜，果然，不出所料，让我找到了一个好东西，如下图这样的： 发现惊喜因为通过前面拿到当前播放的音乐的url源地址，猜想着所有的音乐的url应该都包含着mp3的后缀，所以，我就Ctrl+F，进行mp3的搜索，果然，看到包含mp3的请求就那几个，然后逐一分析，发现，有一个请求信息，也就是上图中的第一个请求，是一个MP3文件资源，所以，我猜想，这个应该就是我需要的音乐URL了吧，然后我拿到这个URL继续去下载文件资源，果然，这就是我需要的音乐URL源地址，到这里，也就是找到了这个因为版权受限不让播放和下载的音乐了，惊不惊喜？意不意外？ Python下载MP3文件源码最后，分享一波Python下载MP3资源的源码，使用的时候，得先进行几个配置，首先是url，url就是需要下载的音乐URL地址，folder就是音乐需要保存的位置，话不多说，直接上源码 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-"""下载MP3文件author: gxcuizytime：2018-08-08"""import requestsimport osdef download_file(mp3_url, file_folder): """下载MP3文件""" # 文件夹不存在，则创建文件夹 folder = os.path.exists(file_folder) if not folder: os.makedirs(file_folder) # 读取远程MP3资源 res = requests.get(mp3_url) res.raise_for_status() # 获取文件名 file_name = os.path.basename(mp3_url) file_path = os.path.join(file_folder, file_name) print('正在写入资源文件：', file_path) # 保存到本地 image_file = open(file_path, 'wb') for chunk in res.iter_content(100000): image_file.write(chunk) image_file.close() print('写入文件结束！')# 程序主入口if __name__ == "__main__": # MP3源地址url url = 'http://m10.music.126.net/20180808172234/4446d41c850238c25cdcff1fe43249a4/ymusic/3686/b5b4/961c/39c9a20e7db813ea3290e1b1580cfa70.mp3' # MP3保存文件夹 folder = 'mp3/' # 调用下载方法 download_file(url, folder) 结束语大家有什么不理解或者不明白的的，可以联系我，或者给我留言，我会及时回复的，欢迎沟通和交流，谢谢。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python通过paramiko从远处服务器下载文件资源到本地]]></title>
    <url>%2F2018%2F08%2F02%2FPython%E9%80%9A%E8%BF%87paramiko%E4%BB%8E%E8%BF%9C%E5%A4%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[为什么要用Python脚本下载以及基本介绍经常会有人需要从远程服务器下载一些文件资源，下载个别小文件可以直接用sz等命令，但是，需要下载一个文件夹呢？sz就不行了，这时候当然可以先压缩文件夹，然后下载，这样也是可以的，只要文件不是很大，那么，有没有其他办法下载文件夹呢？办法当然是有的，就是写Python脚本，然后通过paramiko模块就可以从远程传输下载文件夹到本地了，是不是很方便呢…… paramiko模块提供了ssh及sftp进行远程登录服务器执行命令和上传下载文件的功能。这是一个第三方的软件包，使用之前需要先进行安装，我们这里主要利用sftp进行下载传输文件 就像下图中的运行，可以一个一个的循环下载文件 使用时候的基本配置下面的这些信息需要自己配置一下，即初始化一些参数，包括服务器信息以及远程文件和本地文件的存放路径配置 123456789# 服务器连接信息host_name = '172.0.0.1'user_name = 'root'password = 'root'port = 22# 远程文件路径（需要绝对路径）remote_dir = '/data/nfs/zdlh/pdf/2018/07/31'# 本地文件存放路径（绝对路径或者相对路径都可以）local_dir = 'file_download/' 实现源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-"""通过paramiko从远处服务器下载文件资源到本地author: gxcuizytime: 2018-08-01"""import paramikoimport osfrom stat import S_ISDIR as isdirdef down_from_remote(sftp_obj, remote_dir_name, local_dir_name): """远程下载文件""" remote_file = sftp_obj.stat(remote_dir_name) if isdir(remote_file.st_mode): # 文件夹，不能直接下载，需要继续循环 check_local_dir(local_dir_name) print('开始下载文件夹：' + remote_dir_name) for remote_file_name in sftp.listdir(remote_dir_name): sub_remote = os.path.join(remote_dir_name, remote_file_name) sub_remote = sub_remote.replace('\\', '/') sub_local = os.path.join(local_dir_name, remote_file_name) sub_local = sub_local.replace('\\', '/') down_from_remote(sftp_obj, sub_remote, sub_local) else: # 文件，直接下载 print('开始下载文件：' + remote_dir_name) sftp.get(remote_dir_name, local_dir_name)def check_local_dir(local_dir_name): """本地文件夹是否存在，不存在则创建""" if not os.path.exists(local_dir_name): os.makedirs(local_dir_name)if __name__ == "__main__": """程序主入口""" # 服务器连接信息 host_name = '172.17.2.18' user_name = 'dev' password = 'dev@zdlh' port = 22 # 远程文件路径（需要绝对路径） remote_dir = '/data/nfs/zdlh/pdf/2018/07/31' # 本地文件存放路径（绝对路径或者相对路径都可以） local_dir = 'file_download/' # 连接远程服务器 t = paramiko.Transport((host_name, port)) t.connect(username=user_name, password=password) sftp = paramiko.SFTPClient.from_transport(t) # 远程文件开始下载 down_from_remote(sftp, remote_dir, local_dir) # 关闭连接 t.close() 结束语在Python中，可以很好地利用Parmmiko的sftp完成文件传输操作。大家有什么疑问或者想法，可以留言或者联系我。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包工具推荐：Fiddler、Charles]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%EF%BC%9AFiddler%E3%80%81Charles%2F</url>
    <content type="text"><![CDATA[1、抓包工具FilddlerFiddler是最强大最好用的Web调试工具之一,它能记录所有客户端和服务器的http和https请求,允许你监视,设置断点,甚至修改输入输出数据,Fidder包含了一个强大的基于事件脚本的子系统,并且能使用.net语言进行扩展 下载地址 https://www.telerik.com/download/fiddler 安装使用教程 https://www.cnblogs.com/R-bear/p/7508133.html 2、抓包工具CharlesCharles是常用的截取网络封包的工具(俗称抓包)。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 下载地址 https://www.charlesproxy.com/download 安装使用教程 https://zhubangbang.com/charlesproxy]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP推荐编码规范]]></title>
    <url>%2F2018%2F07%2F26%2FPHP%E6%8E%A8%E8%8D%90%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[我们为什么需要编码规范？ 为了提高工作效率，保证开发的有效性和合理性 为了提高代码可读性和可重复利用性，从而节约沟通成本 1. 排版 程序块要采用缩进风格编写，缩进的格式建议为4个空格，单模块内必须统一 关键字与其后的左括号之间有一个空格，而函数名与左括号之间不应有任何字符包括空格 if / while等逻辑结构体，即使只有一行，也必须加上花括号包含，不建议写成一行，增加可读性 同一个代码块的变量定义， 应该尽可能集中在块开始位置，提高可读性 2. 命令 常量命名必须全部大写字母，单词之间以下划线’_’连接 关键字true、false、null必须小写 类的命名采用驼峰法（首字母大写） 类的方法命名采用驼峰命名（首字母小写） 普通函数的命名采用过程函数风格命名，即使用小写字母和下划线（小写字母开头）的方式 类成员变量和局部变量必须采用驼峰命名法（首字母小写） 以单下划线“_”打头的函数或方法作为私有方法 以双下划线“__”打头的函数或方法作为魔术方法 3. 注释 建议文件、函数、类以及成员变量都应包含注释，关键代码必须有注释 单行注释用//，不能使用#作为单行注释， 多行注释\/* **\/不能出现在同一行 方法或者函数必须通过param和return标记指明其参数和返回值 4. 编码原则 生成对象时，必须使用new ClassName()，不要用new ClassName 除非特殊情况，否则不允许使用require和include，而使用对应的require_once/include_once 能用foreach的就不要用for，能用for的就不要用while 字符串尽量用’ ‘而不是” “进行引用，一个是效率问题，一个是安全问题 函数允许使用默认参数，但是默认参数需要放到参数列表最后面 禁止使用and、or， 而是使用&amp;&amp;、|| $i, $j这样无意义的变量名，除非是用作循环计数变量 5. 数据表和字段 数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头 不建议使用驼峰和中文作为数据表字段命名 6. 代码性能 把重复调用放在循环体外 不要在你的提交的代码中包含调试代码，就算是注释掉了也不行 运行代码时不应该出现任何错误信息，并不是把警告和提示信息关掉来满足这一点 最后最后说的是，规范也不是死的或者强制的，只是一种编码建议，更加不是标准。“约定大于规范”，如果有的规范太死板，不适应您的团队，您可以不采用，按照您自己的规范即可。当然了，你有任何问题，都可以与我交流和联系。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog,that is my first article. Quick StartCreate a new post1$ hexo new "My New Post" Run server1$ hexo server Generate static files1$ hexo generate Deploy to remote sites1$ hexo deploy]]></content>
  </entry>
</search>
