<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3爬取英雄联盟英雄皮肤大图]]></title>
    <url>%2F2018%2F11%2F14%2FPython3%E7%88%AC%E5%8F%96%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E8%8B%B1%E9%9B%84%E7%9A%AE%E8%82%A4%E5%A4%A7%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言上篇文章，说到了，爬取LOL英雄皮肤的高清图片，最近有事，也没怎么去研究，所以，现在才去看了下，并且写了Python脚本来抓取皮肤图片。需要说明一下，这个脚本有部分英雄没有抓取到，但是具体原因，我目前还没搞懂，我是相当纳闷的。大家有兴趣的，可以看看后面遗留问题，一起研究下。 爬虫思路初步尝试我先查看了network，并没有发现有可用的API；然后又用bs4去分析英雄列表页，但是请求到html里面，并没有英雄列表，在英雄列表的节点上，只有“正在加载中”这样的字样；同样的方法，分析英雄详情也是这种情况，所以我猜测，这些数据应该是Javascript负责加载的。 继续尝试然后我就查看了英雄列表的源代码，查看外部引入的js文件，以及行内的js脚本，大概在368行，发现了有处理英雄列表的js注释，然后继续往下读这些代码，发现了第一个彩蛋，也就是他引入了一个champion.js的文件，我猜测，这个应该就是英雄列表大全了，然后我打开了这个链接的js，一眼看过去，黑麻麻一片，然后格式化了一下压缩的js，确定这就是英雄列表的js数据文件了。 接着尝试前面通过查看列表的源代码，找到了英雄列表的js数据文件，那么，我继续随机点开了一个英雄的详情，然后查看英雄详情源代码，然后大概在568行看到有一个showSkin的js方法，通过这里，发现了第二个彩蛋，也就是皮肤图片的URL地址拼接方法。 最后尝试上面找到了皮肤图片URL的拼接方法，并且发现了一行很关键的代码var skin =LOLherojs.champion[heroid].data.skins，也就是，这个skin变量，就是英雄皮肤的所有图片数组，但是这个文件内，并没有LOLherojs这个变量，也就是外部引入的，所以，需要继续查看下面的源代码，找到引入这个变量的位置，果不其然，在757行，发现了最后一个彩蛋，也就是，英雄皮肤的js文件，通过这里可以知道，每个英雄都有一个单独的js文件，并且知道了这个js文件的URL拼接方法。 思路总结通过上面的分析，我们就得到了爬取LOL皮肤图片的所有数据准备了，也就是，直接，只需要提取js中的英雄列表以及英雄详情数据，就可实现我们的需求了。下面是运行后抓取到的图片…… 运行环境Python运行环境：python3.6用到的模块：requests、json、urllib、os、lxml未安装的模块，请使用pip instatll进行安装，例如：pip install requests 完整代码其他啥的废话就不多说了，直接上完整代码，有问题，直接留言给我就行，另外，代码已上传GitHub。再说明一下，那些有问题的英雄详情的js文件，大家有时间也可以琢磨下，或者有其他的更加快捷的爬取这些图片的方法，也可以拿出来交流和讨论，谢谢。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python# -*- coding: utf-8 -*-"""抓取英雄联盟英雄全皮肤author: gxcuizydate: 2018-11-13"""import requestsimport jsonfrom urllib import parseimport osclass GetLolSkin(object): """抓取LOL英雄皮肤""" def __init__(self): """初始化变量""" self.hero_url = 'https://lol.qq.com/biz/hero/champion.js' self.hero_detail_url = 'http://lol.qq.com/biz/hero/' self.skin_folder = 'skin' self.skin_url = 'https://ossweb-img.qq.com/images/lol/web201310/skin/big' @staticmethod def get_html(url): """下载html""" request = requests.get(url) request.encoding = 'gbk' if request.status_code == 200: return request.text else: return "&#123;&#125;" def get_hero_list(self): """获取英雄的完整信息列表""" hero_js = self.get_html(self.hero_url) # 删除左右的多余信息，得到json数据 out_left = "if(!LOLherojs)var LOLherojs=&#123;&#125;;LOLherojs.champion=" out_right = ';' hero_list = hero_js.replace(out_left, '').rstrip(out_right) return json.loads(hero_list) def get_hero_info(self, hero_id): """获取英雄的详细信息""" # 获取js详情 detail_url = parse.urljoin(self.hero_detail_url, hero_id + '.js') detail_js = self.get_html(detail_url) # 删除左右的多余信息，得到json数据 out_left = "if(!herojs)var herojs=&#123;champion:&#123;&#125;&#125;;herojs['champion'][%s]=" % hero_id out_right = ';' hero_info = detail_js.replace(out_left, '').rstrip(out_right) return json.loads(hero_info) def download_skin_list(self, skin_list, hero_name): """下载皮肤列表""" # 循环下载皮肤 for skin_info in skin_list: # 拼接图片名字 if skin_info['name'] == 'default': skin_name = '默认皮肤' else: if ' ' in skin_info['name']: name_info = skin_info['name'].split(' ') skin_name = name_info[0] else: skin_name = skin_info['name'] hero_skin_name = hero_name + '-' + skin_name + '.jpg' self.download_skin(skin_info['id'], hero_skin_name) def download_skin(self, skin_id, skin_name): """下载皮肤图片""" # 下载图片 img_url = self.skin_url + skin_id + '.jpg' request = requests.get(img_url) if request.status_code == 200: print('downloading……%s' % skin_name) img_path = os.path.join(self.skin_folder, skin_name) with open(img_path, 'wb') as img: img.write(request.content) else: print('img error!') def make_folder(self): """初始化，创建图片文件夹""" if not os.path.exists(self.skin_folder): os.mkdir(self.skin_folder) def run(self): # 获取英雄列表信息 hero_json = self.get_hero_list() hero_keys = hero_json['keys'] # 循环遍历英雄 for hero_id, hero_code in hero_keys.items(): hero_name = hero_json['data'][hero_code]['name'] hero_info = self.get_hero_info(hero_id) if hero_info: skin_list = hero_info['result'][hero_id]['skins'] # 下载皮肤 self.download_skin_list(skin_list, hero_name) else: print('英雄【%s】的皮肤获取有问题……' % hero_name)# 程序执行入口if __name__ == '__main__': lol = GetLolSkin() # 创建图片存储文件 lol.make_folder() # 执行脚本 lol.run()]]></content>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
        <tag>json</tag>
        <tag>英雄联盟</tag>
        <tag>LOL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取王者荣耀英雄皮肤高清图片]]></title>
    <url>%2F2018%2F11%2F07%2FPython%E7%88%AC%E5%8F%96%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E8%8B%B1%E9%9B%84%E7%9A%AE%E8%82%A4%E9%AB%98%E6%B8%85%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言临下班前，看到群里有人在讨论用王者农药的一些皮肤作为电脑的壁纸，什么高清的，什么像素稍低的，网上查了一手，也有，但像素都不一样，所以，我就想着，自己去官网直接爬他的高清皮肤就好了，然后就有了这边文章说的主题了。 爬图思路找到英雄列表进入官网，然后进入英雄介绍，查看更多英雄，就能看到全部的英雄了，也就是下面的这个链接 英雄列表：https://pvp.qq.com/web201605/herolist.shtml 英雄详情点击每个英雄进来，就可以看到每个英雄的详细信息，基本介绍以及皮肤展示，而我们需要爬取的皮肤，就在右下角那里，鼠标放上去，就可以逐个展示该皮肤了 小鲁班的详细信息：https://pvp.qq.com/web201605/herodetail/112.shtml 分析皮肤图片URL从上面的这张鲁班的图片中我们可以看到，通过F12定位到皮肤的小图片位置，li元素里有一个img的元素，其中img的src和data-imgname这两个属性，查看一下，就不难知道，src的属性值是小图，而data-imgname则是我们需要的大图URL，但是查看源码，就会发现，在html中，并没有这个属性，所以，需要我们分析这个URL的规律来得到其他英雄的皮肤图片，分析也不难发现，112就是英雄的id，而bigskin-2里面的2即表示这个英雄的第几张皮肤图片 开始编写爬虫脚本第一步：定义一些常用变量 第二步：抓取所有英雄列表 第三步：循环遍历，分析每个英雄皮肤节点 第四步：下载图片 第五步：爬虫结束 完整源码感觉上面七七八八的，说了些啥呀，真是墨迹，还不如直接上代码实在，好吧，我错了，马上交出源码，请各位看官饶恕，同时，代码我也上传了交友网站GitHub。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/env python# -*- coding: utf-8 -*-"""抓取王者荣耀皮肤author: gxcuizydate: 2018-11-06"""import requestsfrom bs4 import BeautifulSoupfrom urllib import parseimport osclass Skin(object): def __init__(self): # 英雄的json数据 self.hero_url = 'https://pvp.qq.com/web201605/js/herolist.json' # 英雄详细页的通用url前缀信息 self.base_url = 'https://pvp.qq.com/web201605/herodetail/' # 英雄详细页url后缀信息 self.detail_url = '' # 图片存储文件夹 self.img_folder = 'skin' # 图片url的通用前缀 self.skin_url = 'https://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/' # 图片url的后缀信息 self.skin_detail_url = '' def get_hero(self): """获取英雄的json数据""" request = requests.get(self.hero_url) hero_list = request.json() return hero_list def get_hero_skin(self, hero_name, hero_no): """获取详细页英雄皮肤展示的信息，并爬图""" url = parse.urljoin(self.base_url, self.detail_url) request = requests.get(url) request.encoding = 'gbk' html = request.text # 获取皮肤信息的节点 soup = BeautifulSoup(html, 'lxml') skip_list = soup.select('.pic-pf-list3') for skin_info in skip_list: # 获取皮肤名称 img_names = skin_info.attrs['data-imgname'] name_list = img_names.split('|') skin_no = len(name_list) # 循环下载皮肤图片 for skin_name in name_list: self.skin_detail_url = '%s/%s-bigskin-%s.jpg' % (hero_no, hero_no, skin_no) skin_no -= 1 img_name = hero_name + '-' + skin_name + '.jpg' self.download_skin(img_name) def download_skin(self, img_name): """下载皮肤图片""" img_url = parse.urljoin(self.skin_url, self.skin_detail_url) request = requests.get(img_url) if request.status_code == 200: print('download-%s' % img_name) img_path = os.path.join(self.img_folder, img_name) with open(img_path, 'wb') as img: img.write(request.content) else: print('img error!') def make_folder(self): """创建图片存储文件夹""" if not os.path.exists(self.img_folder): os.mkdir(self.img_folder) def run(self): """脚本执行入口""" self.make_folder() hero_list = self.get_hero() for hero in hero_list: hero_no = str(hero['ename']) self.detail_url = hero_no + '.shtml' hero_name = hero['cname'] self.get_hero_skin(hero_name, hero_no)# 程序执行入口if __name__ == '__main__': skin = Skin() skin.run() 最后其实思路就是这么简单，当然了，如果有其他思路以及想法的，欢迎留言交流。额，差点忘了，大家有兴趣的，可以尝试一下爬取英雄联盟的所有英雄皮肤高清图片，有其他任何问题，也欢迎留言和交流。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
        <tag>bs4</tag>
        <tag>王者荣耀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的依赖包之pip管理工具的基础使用]]></title>
    <url>%2F2018%2F10%2F26%2FPython%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85%E4%B9%8Bpip%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[pip是什么我们都知道Python很强大，实用性也非常高，其很重要的一个原因就是因为有非常丰富的第三方库类，而pip是Python的的依赖包管理工具，该工具提供了对Python包的查找、下载、安装、卸载等的功能。基本使用到的包都可以在https://pypi.org/上面搜索找到。当然了，官网的包可能涉及翻墙访问的问题，也可以使用国内的镜像，例如豆瓣的镜像http://pypi.douban.com/simple/、清华的镜像https://pypi.tuna.tsinghua.edu.cn/simple等…… 安装pip具体的安装方法可以查看官网的安装说明 官方安装说明地址：https://pip.pypa.io/en/latest/installing/#id7 Windows的用户，需要先到官网下载get-pip.py安装包，然后执行python get-pip.py进行安装 而如果需要在Linux上安装的话，则比较方便和快捷的，直接可以通过yum或者apt-get安装即可 yum安装1sudo yum install python-pip apt-get安装1sudo apt-get install python-pip 更多安装方法请安装文档：https://packaging.python.org/guides/installing-using-linux-tools/#installing-pip-setuptools-wheel-with-linux-package-managers 查看pip版本简写方式1pip -V 完整命令方式1pip --version 利用pip安装模块1pip install [module_name] 查看所有已安装的模块1pip list 如果需要搜索指定的模块的话，可以使用下面的命令 1pip search [module_name] 还可以使用下面的方法（PS：好像不是全起作用） 1pip list | grep [module_name] 查看已安装的某个模块的详细信息1pip show --files [module_name] 检查哪些模块需要更新1pip list --outdated 升级指定的模块1pip install --U [module_name] 卸载已经安装的模块1pip uninstall [module_name] 需要查看更多pip的用法1pip --help 更新pip本身Windows的用户执行下面的命令 1python -m pip install -U pip Linux或者Mac OS的用户执行下面的命令 1pip install -U pip]]></content>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题之计算哪一桶是红酒]]></title>
    <url>%2F2018%2F09%2F29%2F%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%93%AA%E4%B8%80%E6%A1%B6%E6%98%AF%E7%BA%A2%E9%85%92%2F</url>
    <content type="text"><![CDATA[算法原题莫斯科的一位酒商现有六桶酒，容量分别为30升、32升、36升、38升、40升、62升。白酒五桶，红酒一桶。他的酒都是整桶出售，上午卖出了两桶白酒，下午卖出的白酒是上午的两倍。请问：红酒是哪一桶？ 算法思路由于总共有六桶酒，其中白酒五桶，红酒一桶；那么也就是说，下午卖出的N桶白酒的升数是早上卖出的两桶白酒升数的两倍，由于没说明下午卖出了多少桶，所以N是不确定的，也就是N的范围是1-3；但是，从六桶酒可以知道，升数最小的是30升和32升，这两个数的和为62升，那么下午至少卖出124升，即N桶的升数不能小于124，再看看其他桶的升数，所以N只能是3；也就是最终知道，早上卖出两桶白酒，下午卖出三桶白酒，并且早上两桶白酒的升数的两倍等于下午卖出的三桶白酒的升数，然后剩下的一桶就是红酒了。 算法源码12345678910111213141516171819202122232425262728293031323334353637// 六桶酒的升数数组$arr = [30, 32, 36, 38, 40, 62];$len = count($arr);// 随机取两桶假设为白酒for ($i = 0; $i &lt; $len-1; $i++) &#123; for ($j = 1 + $i; $j &lt; $len; $j++) &#123; $twoArr = $arr; // 去掉早上卖出的两桶白酒 unset($twoArr[$i]); unset($twoArr[$j]); $twoArr = array_values($twoArr); // 从剩下的取出三桶假设为白酒 for ($n = 0; $n &lt; $len - 4; $n++) &#123; for ($m = 1 + $n; $m &lt; $len - 3; $m++) &#123; for ($p = 1 + $m; $p &lt; $len - 2; $p++) &#123; // 早上白酒总和 $oneSum = $arr[$i] + $arr[$j]; // 下午白酒总和 $twoSum = $twoArr[$n] + $twoArr[$m] + $twoArr[$p]; // 如果早上卖出白酒的升数的两倍等于下午卖出白酒的升数，那么即符合所求 if ($oneSum * 2 == $twoSum) &#123; echo '早上卖出的白酒是：' . $arr[$i] . '、'. $arr[$j] . '&lt;br&gt;'; echo '下午卖出的白酒是：' . $twoArr[$n] . '、'. $twoArr[$m] . '、'. $twoArr[$p] . '&lt;br&gt;'; echo '所有五桶白酒是：' . $arr[$i] . '、'. $arr[$j] . '、'. $twoArr[$n] . '、'. $twoArr[$m] . '、'. $twoArr[$p] . '&lt;br&gt;'; $tmpArr = $twoArr; // 去掉下午卖出的三桶白酒 unset($tmpArr[$n]); unset($tmpArr[$m]); unset($tmpArr[$p]); // 剩下的一桶就是所求红酒 echo '一桶红酒是：' . current($tmpArr) . '&lt;hr&gt;'; &#125; &#125; &#125; &#125; &#125;&#125; 最后这只我的一种思路和实现方法，算法也不是很优，其他的实现算法还有很多，欢迎大家评论留言，实现语言和方式不限，谢谢。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google/Baidu的搜索技巧]]></title>
    <url>%2F2018%2F09%2F27%2FGoogle-Baidu%E7%9A%84%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言关于搜索问题答案的技能，据不知道从哪里来的调查结果显示，让人意外的是有四分之三的人都没能较好的利用网络搜索。在咨询丰富的互联网中，如何有效地搜索那可是快速寻找答案的关键技能啊；这里给您提供了一些有效利用Google/Baidu搜索的提示，助你快速搜获所需信息。 如何Google/Baidu搜索你是否每次在Google/Baidu时都只是假如空格分隔关键字呢？相对这基本的搜索功能，合理利用搜索“操作符”，可以帮助你获得更加精确的搜索结果。Google搜索地址为“https://www.google.com”,Baidu搜索地址为“https://www.baidu.com”。 site搜索搜索语法：site:url.com ~synonym “keywords” -excludeKey 2016..2018 site:url.com表示只搜索某个网站的页面 ~synonym表示同时搜索近义词 “keywords”表示以整个短语作为搜索关键字，而不是拆开为每个词 -excludeKey表示排除某个关键字 2016..2018表示指定年份时间段内的搜索结果 filetype搜索搜索语法：filetype:pdf keywords inititle:titleName of *PHP filetype:pdf指明只搜索类型为pdf的文档，也可以搜索doc、xls、jpg等所有类型的文档 keywords是关键字搜索 inititle:titleName是指明标题中包含指定关键词的搜索结果 *星号用来代替任意字符，即搜索任意字符+关键字的搜索结果 Google/Baidu学术搜索对于很多在学术研究的多数项目中，只依靠简单的Google/Baidu搜索不能有效达到目的；可以借助使用Google/Baidu学术搜索，其专门用来搜索理论和学术著作的，就是你会在你的论文中引用的那种，其Google学术地址为“https://scholar.google.com”，Baidu学术地址为“http://xueshu.baidu.com”。 author搜索搜索语法：author:name keywords “otherKeywords” author:name只表示搜索name发布的论文 keywords就是普通的关键字搜索 “otherKeywords”前面也说了，表示以整个短语作为搜索关键字，而不是拆开为每个词 其他Google/Baidu搜索技巧其他的搜索技巧还有类似字词定义，数学计算，单位换算等，下面一一罗列。 define字词定义快速查询字词定义，只要在你想了解的单词前面输入define即可，即define:keywords 数学计算快速计算，别费力启动你的计算器软件了；只需要直接在Google/Baidu中输入数学算式就行了，算式可以包含+、-、、/和括号这些基本的算术功能。例如：`(48)/2+18-1`。 单位换算方便的单位换算，只需要输入你想要换算的两种单位即可，例如：100磅=?公斤 快捷键操作我相信很多互联网用户不知道可以使用“Ctrl + F”在本页内查找字符。（PS：快捷键的使用在Windows和Mac上略有不同，本文主要以Windows快捷键为例子说明。如果你使用的是Mac，多数情况用“Command”按钮代替“Ctrl”按钮即可。） 在本页内查找关键字查找中最重要的快捷键，在你正在查看的任一文档或者页面中，按下“Ctrl + F”键，弹出搜索框后，输入你想查找的字符串，立刻所有对应的字符串都会高亮显示。 放大或缩小页面有时候页面字体太小或者在线PDF文档勉强可以阅读，从而需要放大或者缩小页面的需求，你就可以使用“Ctrl + 加号+”或者“Ctrl + 减号-”来放大或者缩小当前页面。 选址浏览器地址栏每次使用鼠标移动到地址栏是费神又费力，只要按下“Ctrl + L”或者“F6”，地址栏即可选中。 切换标签页和程序在电脑上工作，随着每天工作的开展，运行的应用程序和打开的窗口越来越多，这个时候，可以使用快捷键帮助你在不同的窗口和应用程序间切换，减轻你的烦乱。切换标签页的快捷键为“Ctrl + Tab”，切换窗口快捷键为“Alt Tab” 最后提示 善用你的大脑、书籍。（PS：Google/Baidu搜索固然很给力，但绝不是搜索结果的唯一选择） 学术搜索不要引用维基百科。（PS：维基百科是一个很适合入门的地方，但是很多资料缺乏来源引证） 其他……]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MySQL优化的几点总结]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%85%B3%E4%BA%8EMySQL%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言现如今，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。所以，我整理了MySQL优化的几点建议，希望这些优化技巧对您有用，总结不到的，欢迎大家补充。 SQL执行慢的原因 网络速度慢，内存不足，I/O吞吐量小，磁盘空间满了等硬件问题 没有索引或者索引失效 数据表里的数据记录过多 服务器调优及各个参数设置也可能会影响 开发者编写的SQL效率 其他 1、EXPLAIN分析你的SELECT查询很多情况下，使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的，这可以帮你分析你的查询语句，从而或许能尽快的找到优化方法以及潜在的性能问题。具体EXPLAIN的使用以及各个参数的含义，请查阅相关文档即可。 2、SELECT查询必须指明字段名SELECT * 的查询会加很多不必要的消耗（例如CPU、I/O等），同时，也有可能增加了使用覆盖索引。所以SELECT查询时，要求直接在后面指明需要查询的对应字段名。 3、查询一条数据的时候，使用 LIMIT 1减少多余的查询，因为指定limit 1后，查询到一条数据就不再继续查询了，使得EXPLAIN中type列达到const类型，查询语句更优。 4、为搜索的WHERE字段建立索引一般，每个表我们都会设置一个主键，而索引并不一定就是给主键。如果在你的表中，有某个字段你总要会经常用来做WHERE查询搜索，而且是读大于写的，那么，请为其建立索引吧，有兴趣了解更多建立索引的的原则，可以查阅相关资料。 5、千万不要使用 ORDER BY RAND()如果你想随机取数据，也许第一个直接会告诉你，用随机数取，切记，这个时候你必须控制你的大脑在这个方向继续想下去，赶紧停止这种可怕的想法。因为这种查询，对数据库的性能毫无益处（消耗CPU）。更好的方案之一是先找到数据所在的条数N，然后再用LIMIT N, 1这样查询。 6、保证每张表都有一个主键ID我们应该养成一种习惯，每设计新建一张表的时候，都应该为其设计一个ID字段，并让其成为主键，而且最好是INT型（也有使用UUID的），同时设置这个ID字段为自增（AUTO_INCREMENT）的标志。 8、尽可能的使用 NOT NULL不要以为NULL不需要空间，事实是NULL也需要额外的空间，也许，很多有没注意但是遇到过，NULL字段在进行查询比较的时候，是比较麻烦的。当然了，如果你实在是必须需要NULL的话，那没辙，就使用吧，否则的话，就建议使用NOT NULL吧。 8、选择合适的存储引擎在MySQL中有MyISAM和InnoDB两种存储引擎，两者各有利弊，所以我们需要了解两者的差异然后来做出最合适的选择，例如InnoDB支持事务而MyISAM不支持，MyISAM查询比InnoDB快等等；总之，如果你不知道选择什么的话，那就用InnoDB吧。 9、把IP地址存为UNSIGNED INT在遇到需要存储IP地址的时候，很多人的第一想法都会是存储VARCHAR(15)字符串类型的，而不会想到要用INT整型来存储；如果你用整型来存储，只需要4个字节，并且你可以有定长的字段，而且这会为你带来查询上的优势。 10、尽量不要在WHERE查询时对字段进行null值判断我们都知道，档我们对一个字段进行null的判断时候，会比较慢的，这是因为这个判断会导致引擎放弃使用所有已有的索引而进行全表扫描搜索。 11、尽量不要使用%前缀的LIKE模糊查询模糊查询，在日常开发中，我们都会经常遇到，但是我相信很多人都是直接 LIKE &#39;%key_word%&#39; 或者 LIKE &#39;%key_word&#39; 这样搜索的，这两种搜索方式，都会导致索引失效从而进行全表扫描搜索。如果解决上面的这种模糊查询呢，答案就是使用“使用全文索引”，具体的用法有兴趣的可以自己查资料一波。 12、避免在WHERE查询时对字段进行表达式操作例如查询语句SELECT id FROM table WHERE num * 2 = 50;，这样的查询，对字段num做了一个乘2的算数操作，就会导致索引失效。 14、减少不必要的排序排序操作会消耗较多的CPU资源，所以减少不必要的排序可以在缓存命中率高等I/O足够的情况下，会降低SQL的响应时间。 14、建议用JOIN代替子查询有的人会说，JOIN的性能其实也并不是很好呀，但是和子查询比起来还是有很大的性能优势的。具体的，可以了解一下子查询的执行计划相关的问题。 15、避免发生隐式类型转换类型转换主要是指在WHERE子句中出现字段的类型和传入的参数类型不一致的时候发生的类型转换；这是因为如果我们传入的数据类型和字段类型不一致，MySQL可能会对我们传的数据进行类型转换操作，也可能不进行处理而直接交由存储引擎去处理，这样一来，就可能会出现索引无法使用的情况而造成执行计划问题。 16、避免多表查询字段类型不一致在遇到需要多表联合查询的时候，我们设计表结构的时候，尽量保持表与表的关联字段一致，并且都要设置索引。同时，多表连接查询时，尽量把结果集小的表作为驱动表。 17、建议开启查询缓存大多数的MySQL服务器都开启了查询缓存，这是提高性能最有效的方法之一，因为查询缓存由MySQL数据库引擎自动处理，当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表，而直接访问缓存结果了。 18、使用UNION代替临时表UNION查询可以把两条或更多的SELECT查询结果合并到一个查询中，从而不再需要创建临时表来完成。需要注意的是，使用UNION的所有SELECT语句中的字段数目要相同。 19、慎用IN查询IN以及NOT IN查询都要慎重，因为可能会导致全表扫描，而对于连续的数值，能用BETWEEN就不要用IN了。 20、欢迎补充结束语这主要是从查询角度去考虑优化，还有一些分表、分区技术以及读写分离等；以上优化之处，如果说的不到位的地方，请大家谅解，MySQL优化的地方可以有很多处，欢迎提出其他优化建议，谢谢。]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法之二分查找]]></title>
    <url>%2F2018%2F09%2F20%2FPHP%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找的定义 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 算法的要求从上面的定义我们可以知道，满足该算法的要求必须如下两点： 必须采用顺序存储结构。 必须按关键字大小有序排列。 算法的步骤其实，二分查找也还是比较容易理解的，大概就是一分为二，然后两边比较，保留有效区间，继续一分为二查找，直到找到或者超出区间则结束，所以二分查找的基本步骤是： 确定要查找的区间 确定要二分时的参照点 区间内选取二分点 根据二分点的值，综合左右区间情况以及求解的目的，舍去一半无用的区间 继续在有效区间重复上面的步骤 算法源码这里，我主要采用递归和非递归两种方法实现，具体如下： 首先第一种是非递归的算法实现，算法如下： 123456789101112131415161718192021222324252627282930313233/** * 二分查找算法 * @param array $arr 待查找区间 * @param int $number 查找数 * @return int 返回找到的键 */function binary_search($arr, $number) &#123; // 非数组或者数组为空，直接返回-1 if (!is_array($arr) || empty($arr)) &#123; return -1; &#125; // 初始变量值 $len = count($arr); $lower = 0; $high = $len - 1; // 最低点比最高点大就退出 while ($lower &lt;= $high) &#123; // 以中间点作为参照点比较 $middle = intval(($lower + $high) / 2); if ($arr[$middle] &gt; $number) &#123; // 查找数比参照点小，舍去右边 $high = $middle - 1; &#125; else if ($arr[$middle] &lt; $number) &#123; // 查找数比参照点大，舍去左边 $lower = $middle + 1; &#125; else &#123; // 查找数与参照点相等，则找到返回 return $middle; &#125; &#125; // 未找到，返回-1 return -1;&#125; 然后第二种是递归的算法实现，算法如下： 123456789101112131415161718192021222324/** * @param array $arr 待查找区间 * @param int $number 查找数 * @param int $lower 区间最低点 * @param int $high 区间最高点 * @return int */function binary_search_recursion(&amp;$arr, $number, $lower, $high) &#123; // 以区间的中间点作为参照点比较 $middle = intval(($lower + $high) / 2); // 最低点比最高点大就退出 if ($lower &gt; $high) &#123; return -1; &#125; if ($number &gt; $arr[$middle]) &#123; // 查找数比参照点大，舍去左边继续查找 return binary_search_recursion($arr, $number, $middle + 1, $high); &#125; elseif ($number &lt; $arr[$middle]) &#123; // 查找数比参照点小，舍去右边继续查找 return binary_search_recursion($arr, $number, $lower, $middle - 1); &#125; else &#123; return $middle; &#125;&#125; 算法的使用需求是在一个排列好的区间（$arr）中，查找一个数（$number）的所在位置，所以，调用算法查找如下： 123456789// 待查找区间$arr = [1, 3, 7, 9, 11, 57, 63, 99];// 非递归查找66所在的位置$find_key = binary_search($arr, 57);// 递归查找66所在的位置$find_key_r = binary_search_recursion($arr, 57, 0, count($arr));// 输出打印print_r($find_key);print_r($find_key_r); 时间复杂度分析在有序数组中如果用暴力的算法去查找，也就是逐个遍历比较，那么时间复杂度是O(n)；但是，用二分查找后，因为每次可以舍去一半查找区间，所以会将时间复杂度减少到O(logn)，算法更优。 最后又到了无聊的客套话时间，老规律，有问题直接留言，有想法直接说，有错误直接提出来，我都会及时回复的，谢谢。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法之四大基础算法]]></title>
    <url>%2F2018%2F09%2F19%2FPHP%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言虽然工作中，你觉得自己并没有涉及到算法这方面的东西，但是算法是程序的核心，一个程序的好与差，关键是这个程序算法的优劣，所以对于冒泡排序、插入排序、选择排序、快速排序这四种基本算法，我想还是要掌握的。 冒泡排序法 冒泡排序大概的意思是依次比较相邻的两个数，然后根据大小做出排序，直至最后两位数。由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。 冒泡是从前往后冒，所以，每轮比较的次数也是逐渐减少的，最后一个数不用比较，其时间复杂度为O(n²)，算法如下： 123456789101112131415161718192021222324/** * 冒泡排序算法 * @param array $arr * @return array */function bubble_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; // 循环需要冒泡的轮数 for ($i = 1, $len = count($arr); $i &lt; $len; $i++) &#123; // 循环每轮需要比较的次数 for ($j = 0; $j &lt; $len - $i; $j++) &#123; // 大的数，交换位置，往后挪 if ($arr[$j] &gt; $arr[$j + 1]) &#123; $temp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $temp; &#125; &#125; &#125; return $arr;&#125; 选择排序法 选择排序的原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；以此类推，直到所有元素均排序完毕。 选择是每一次从假定一个最小值的位置，然后用假定最小值和后面的值依次比较，找到实际的最小值来放到假定最小值的位置上，其时间复杂度也为O(n²)，算法如下： 123456789101112131415161718192021222324252627282930/** * 选择排序法 * @param array $arr * @return array */function select_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; $len = count($arr); for ($i = 0; $i &lt; $len - 1; $i++) &#123; // 假设最小数的位置 $min = $i; // 用假设的最小数和$i后面的数循环比较，找到实际的最小数 for ($j = $i + 1; $j &lt; $len; $j++) &#123; // 后面的数比假设的最小数小，替换最小数 if ($arr[$min] &gt; $arr[$j]) &#123; $min = $j; &#125; &#125; // 假设的最小数和实际不符，交换位置 if ($min != $i) &#123; $temp = $arr[$min]; $arr[$min] = $arr[$i]; $arr[$i] = $temp; &#125; &#125; return $arr;&#125; 插入排序法 插入排序的原理：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。 插入排序法是先将排序元素的前两个元素排序，然后将第三个元素插入已经排序好的两个元素中，所以这三个元素仍然是从小到大排序，接着将第四个元素插入，重复操作直到所有元素都排序好；其时间复杂度同样为O(n²)，算法如下： 12345678910111213141516171819202122232425/** * 插入排序法 * @param array $arr * @return array */function insert_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; $len = count($arr); for ($i = 1; $i &lt; $len; $i++) &#123; // 当前需要比较的临时数 $tmp = $arr[$i]; // 循环比较临时数所在位置前面的数 for ($j = $i - 1; $j &gt;= 0; $j--) &#123; // 前面的数比临时数大，则交换位置 if ($arr[$j] &gt; $tmp) &#123; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr;&#125; 快速排序法 快速排序法是对冒泡排序的一种改进。他的基本原理是：通过一趟排序将待排记录分割成独立的两部分，其中一部分的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行快速排序，整个排序过程可以递归进行，以达到整个序列有序的目的。 快速排序法是从数列中挑出第一个数（最后一个数）作为基准元素，然后循环所有数，和基准书比较分为左右两列，然后重复这样的步骤继续划分为左右两列，算法如下： 1234567891011121314151617181920212223242526272829303132/** * 快速排序法 * @param array $arr * @return array */function quick_sort($arr) &#123; // 判断参数是否为数组，且不为空 if (!is_array($arr) || empty($arr)) &#123; return $arr; &#125; // 数组长度为1停止排序 $len = count($arr); if ($len == 1) &#123; return $arr; &#125; // 声明左右两个空数组 $left = $right = []; // 循环遍历，把第一个元素当做基准数 for ($i = 1; $i &lt; $len; $i++) &#123; // 比较当前数的大小，并放入对应的左右数组 if ($arr[$i] &gt; $arr[0]) &#123; $right[] = $arr[$i]; &#125; else &#123; $left[] = $arr[$i]; &#125; &#125; // 递归比较 $left = quick_sort($left); $right = quick_sort($right); // 左右两列以及基准数合并 return array_merge($left, [$arr[0]], $right);&#125; 使用方法声明一个待排序的数组，然后调用对应的排序方法即可得到返回的排序好的数组；说明一下，我这里的排序设计都是递增的，如果需要递减，需要修改一下排序算法的比较替换符就行。 123456// 待排序数组$arr = [1, 4, 5, 9, 3, 8, 6];// 调用排序方法$sort_arr = bubble_sort($arr);// 输出打印print_r($sort_arr); 分析算法通常，对于一个给定的算法，我们要做两项分析：第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，第二步就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。还有我们通常说的：算法优化无非就是以时间换空间，以空间换时间，一般这两者是不可兼得。 结束语实现一个程序，肯定是有多种算法的，大家有其他想说的，都可以留言和我交流，谢谢！如有问题，也欢迎指出，我会及时改正，谢谢！]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法之判断是否是质数]]></title>
    <url>%2F2018%2F09%2F18%2FPHP%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[质数的定义 质数又称素数。一个大于1的自然数，除了1和它自身外，不能整除其他自然数的数叫做质数；否则称为合数。 实现思路循环所有可能的备选数字，然后和中间数以下且大于等于2的整数进行整除比较，如果能够被整数，则肯定不是质数，相反，就是质数。 第一种算法这也是最可能先想到的，也就是直接和备选数的中间数去比较，算法源码如下： 123456789101112131415161718192021222324252627/** * 获取所有的质数 * @param array $arr * @return array */function get_prime_number($arr = []) &#123; // 质数数组 $primeArr = []; // 循环所有备选数 foreach ($arr as $value) &#123; // 备选数和备选数的中间数以下的数字整除比较 for ($i = 2; $i &lt;= floor($value / 2); $i++) &#123; // 能够整除，则不是质数，退出循环 if ($value % $i == 0) &#123; break; &#125; &#125; // 被除数$j比备选数的中间数大的则为质数 // 这样判断的依据： // 假如备选数为质数，则内层的for循环不会break退出，则执行完毕，$i会继续+1，即最后$i = floor($value / 2) + 1 // 假如备选数不为质数，则内层的for循环遇到整除就会break退出，$i不会继续+1，即最后$i &lt;= floor($value / 2) if ($value != 1 &amp;&amp; $i &gt; floor($value / 2)) &#123; $primeArr[] = $value; &#125; &#125; return $primeArr;&#125; 第二种算法认真的来说的话，这也不算是另外一种算法，只是对于第一种的稍微点点优化，及中间最大数的优化，缩小比较范围，算法源码如下： 123456789101112131415161718192021222324252627/** * 获取所有的质数 * @param array $arr * @return array */function get_prime_number($arr = []) &#123; // 质数数组 $primeArr = []; // 循环所有备选数 foreach ($arr as $value) &#123; // 备选数和备选数的中间数以下的数字整除比较 for ($i = 2; $i &lt;= floor($value / $i); $i++) &#123; // 能够整除，则不是质数，退出循环 if ($value % $i == 0) &#123; break; &#125; &#125; // 被除数$j比备选数的中间数大的则为质数 // 这样判断的依据： // 假如备选数为质数，则内层的for循环不会break退出，则执行完毕，$i会继续+1，即最后$i = floor($value / $i) + 1 // 假如备选数不为质数，则内层的for循环遇到整除就会break退出且$i不会继续+1，即最后$i &lt;= floor($value / $i) if ($value != 1 &amp;&amp; $i &gt; floor($value / $i)) &#123; $primeArr[] = $value; &#125; &#125; return $primeArr;&#125; 第三种算法这个的话也是对于第二种的优化，即，直接从完整数组中删除所有不是质数的数即可，算法源码如下： 1234567891011121314151617181920212223242526/** * 获取所有的质数 * @param array $arr * @return array */function get_prime_number_three($arr = []) &#123; // 质数数组 $primeArr = $arr; // 循环所有备选数 foreach ($primeArr as $key =&gt; $value) &#123; if ($value == 1) &#123; unset($primeArr[$key]); continue; &#125; // 备选数和备选数的中间数以下的数字整除比较 for ($i = 2; $i &lt;= floor($value / $i); $i++) &#123; // 能够整除，则不是质数，从数组中删除且退出循环 if ($value % $i == 0) &#123; unset($primeArr[$key]); break; &#125; &#125; &#125; // 重置数组索引返回 return array_values($primeArr);&#125; 使用方法比如，求1-100的所有质数123456// 所有备选数数组$numberArr = range(1, 100, 1);// 获取备选数中的所有质数$primeNumberArr = get_prime_number($numberArr);// 输出打印print_r($primeNumberArr); 又比如，求指定数组中的所有质数123456// 所有备选数数组$numberArr = [11, 22, 33, 66, 77, 3, 8, 10, 99];// 获取备选数中的所有质数$primeNumberArr = get_prime_number($numberArr);// 输出打印print_r($primeNumberArr); 最后如有说的不对的地方，请大家多多谅解，欢迎留言和我沟通、交流，谢谢！]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面试总结]]></title>
    <url>%2F2018%2F09%2F11%2FPHP%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言面试是你进入公司的第一个关卡，如同高考一般，但是面试不是高考，高考只有一次，而面试则可以有N次，只要有合适的面试邀请，你就可以继续尝试，不要害怕失败；假如公司没有选择你，不是你不优秀，只是你不符合他们的要求罢了，结束后总结下面试中不足的地方，及时调整好心态，准备下个面试才是你最正确的做法。 面试准备俗话说：“将军不打没准备的仗”，参加高考也是需要寒窗苦读12年甚至更久，而求职面试呢，也是需要提前准备的，主要分如下几个方面来准备： 自我介绍，这个不用我说了吧，几乎每场面试都会遇到 PHP基础语法和函数 提前准备好怎么在面试官面前表述自己的项目（体现用到的技术与亮点/难点） 简历上自己的列出的专业技能，要看一下相关知识点，因为面试官会从你的这些技能中问你问题 MySQL数据库方面，比如事务处理、索引、锁、查询优化、表结构设计等 PHP进阶方面，例如MVC、OOP、算法、设计模式、redis等 Javascript、Ajax、jQuery等前端知识，会Vue或者Node.js一般会有加分呢 丰富GitHub项目、博客以及自己活跃的社区主页信息等 准备好你的个人简历 …… 技术面试知识点MySQL索引 索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度，从而提高性能，是MySQL查询优化之一。 更多索引相关详见 https://segmentfault.com/a/1190000003072424 MySQL优化现如今，各种大数据、高并发的时代，数据库的操作越来越成为整个架构的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时，我们都需要注意数据操作的性能。而在面试过程中，也是经常会遇到的，所以，无论是面试准备还是日常开发，我们都应该关注这方面的东西。 更多优化方法和技巧详见 https://coolshell.cn/articles/1846.html MySQL事务我们都知道，事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位；所以MySQL事务主要用于处理操作量大，复杂度高的数据。 MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务；一般来说，事务都具备4个特性（ACID）：：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 更多MySQL事务详见 https://www.jianshu.com/p/bcc614524024 MyISAN与InnoDB的区别MyISAN与InnoDB都是MySQL的数据库引擎之一，在5.5版之前MyISAM是MySQL的默认数据库引擎；MyISAN虽然性能极佳，但却有一个缺点：不支持事务处理（transaction），而恰恰相反，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，所以，如果在日常开发中，如果遇到不知道选择哪种表类型的，那么就选择InnoDB吧。 更多MyISAN与InnoDB的的比较详见 https://www.jianshu.com/p/a957b18ba40d HTTP协议 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW: World Wide Web）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据，HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统，他的主要特点是：简单快速、灵活、无连接、无状态、支持B/S及C/S模式等。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 更多有关HTTP协议详见 https://www.jianshu.com/p/80e25cb1d81a TCP/IP协议从字面意义上讲，有人可能会认为TCP/IP是指TCP和IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。他们与TCP或IP的关系紧密，是互联网必不可少的组成部分。TCP/IP一词泛指这些协议，因此，有时也称TCP/IP为网际协议群。 更多内容详见 https://juejin.im/post/5a069b6d51882509e5432656 四大基础算法虽然工作中，你觉得自己并没有涉及到算法这方面的东西，但是算法是程序的核心，一个程序的好与差，关键是这个程序算法的优劣，所以对于冒泡排序、插入排序、选择排序、快速排序这四种基本算法，我想还是要掌握的。 通常，一个需求可以有多种算法实现，所以除了理解算法的实现之外，我们还需要关注算法的执行时间以及性能评估，这样，才能找到最优算法，而时间复杂度和空间复杂度就是衡量一个算法的优劣。 更多算法知识点详见 https://www.jianshu.com/p/a8cd6cbf733d更多时间和空间复杂度详见 https://blog.csdn.net/zolalad/article/details/11848739 二分算法/二分查找这个算法常用于在一个有序数组中查找某个值第一次出现的位置、最后出现的位置、或者是一段区间。用二分法后，由于每次可以去掉一半无用的区间，会将时间复杂度减少到O(logn)，而通常，二分算法可以用递归以及不递归实现，这两种建议都了解下。 二分法的基本做法是：1、确定要查找的区间。2、确定要二分时的参照点。2、区间内选取二分点。3、根据二分点的值，综合左右区间情况以及求解的目的，舍去一半无用的区间。 更多二分算法解析详见 https://juejin.im/entry/585917c661ff4b006cba47cf PHP7的新特性 PHP7将在2015年10月正式发布，PHP7，将会是PHP脚本语言的重大版本更新，同时将带来大幅的性能改进和新的特性，以及改进一些过时功能。该发布版本将会专注在性能加强，源自PHP版本树中的phpng分支。在硅谷公司的ZendCon会议，PHP工具厂商Zend技术官方讨论phpng和PHP7的进度。“（本次升级）真正专注于帮助业界的应用程序显著加强执行速度，再加上，我们在PHP中的其他改进，”Zend的首席执行官安迪特曼斯 （曾参与了PHP语言的持续开发和发展）表示。 PHP7的新特性主要有：标量类型声明、返回值类型声明、null合并运算符、太空船操作符、通过define()定义常量数组、匿名类等。 PHP7新特性详见 http://php.net/manual/zh/migration70.new-features.php Nginx和Php-fpm的工作原理我们知道Nginx (engine x)是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务器。而Php-fpm是FastCGI的实现，并提供了进程管理的功能。因为Nginx不只有处理http请求的功能，还能做反向代理；所以Nginx通过反向代理功能将动态请求转向后端Php-fpm。 更多原理详见 https://segmentfault.com/a/1190000007322358 ThinkPHP5/Lavavel的执行流程分析例如从入口到控制器都干了啥、一个URL请求到达路由这里是怎么再到相应的控制器等，这可能涉及框架的源码分析，这个在面试过程中，我相信有不少人遇到过，具体的我就不多说了，需要在自己多去研究和分析了。 ThinkPHP5/Lavavel的比较大家都知道，ThinkPHP5是国人开发的，各种参考文档都比较全，适合快速入门，而Laravel则是比较优雅的框架，也号称是最艺术的。这两种框架，都有自己很大的用户群体，有网友说：“ThinkPHP5的优势在于好用，Laravel的优势在于装逼。”具体的比较，请大家可以Google或者Baidu查询更多比较详情。 项目的攻坚点/架构攻坚点这个就需要读者结合自己的项目经验进行总结归纳了，主要包括工作中遇到的问题和解决方案，也就是，这个项目中你的特长之处，做的比较好的方面以及攻克的技术难点。 架构的话呢，这个也会有问到的，我就在面试过程中，被遇到过很多次，你可以说一下自己最近这个项目的一个架构就行，后者，说一下你最熟悉的一个项目的架构也行，具体的可以自己查找相关资料深入了解。 Linux知识Linux是开源的、免费的操作系统，稳定性、安全性与并发性得到业界公认，是一个统称，常见的CentOS、Ubuntu、Rethat…… Linux的特点主要有：开源、免费、多线程、多用户、安全性好、对内存和文件管理优越等；面试中，一般会问到一些你对于Linux的命令和用法的熟悉程度，如果你日常开发中，经常用到，那么我相信面试应该也不成问题，但是也还需要多了解一点。 OOP和MVC的理解 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。 PHP面向对象的三大特性是：封装、继承、多态；同时OOP软件的三个目标是：重用性、拓展性、灵活性。所以，采用OOP这种编程思想和技术为编程人员敞开了一扇大门，使其编程的代码更简洁、更易于维护，并且具有更强的可重用性。 MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 关于OOP的更多详见 http://www.runoob.com/php/php-oop.html关于MVC的更多详见 http://www.manongjc.com/article/1864.html 设计模式 在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。其中，常见的设计模式有：工厂模式、单例模式等。 有关设计模式的更多请详见 http://larabase.com/collection/5/post/143 Redis和MemcacheRedis和Memcache都属于内存(memory)键-值(key-value)数据库，在设计和思想上有许多相同之处，功能和应用在很多场合(如分布式缓存服务)也相似。它们都从属于数据库解决方案中的nosql家族，由于两者都将数据存储在内存中，自然而然，它们都是非常理想的缓存实现方案。 Memcache最初是由Brad Fitzpatrick于2003年开发而成。而Redis则由Salvatore Sanfilippo于2009年创建，它本身也从Memcache上吸取借鉴大量宝贵经验教训，被称为“强化版Memcache”。确实，Redis在功能多样性方面要胜过Memcache，虽然强大且更具灵活性，但复杂程度也比Memcache更甚。而Redis和Memcache的不同点主要体现在：数据类型支持不同、内存管理机制不同、数据持久化支持、集群管理的不同等。 有关比较详情查看 https://www.biaodianfu.com/redis-vs-memcached.html 前端技术也许有的人会说，我作为一名后端开发人员，我需要学习前端技术吗？答案是肯定的，不管是对于工作还是自己的职业发展规划，前端技术都是需要学习和掌握的，例如Javascript、Jquery、Ajax都要了解的，如果会Vue或者Node.js等更好。在面试中，偶尔会涉及到一些。 Jsonp跨域的使用和原理PHP处理跨域一般有三种方法：服务器代理、Jsonp、服务器脚本增加支持；有些网站处于安全考虑, 不会设置允许跨域, 而我们又刚好会用到一次跨域请求, 那么, Jsonp就派上用场了。 Jsonp如何实现跨域：由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 其他更多有关Jsonp的用法，可以自行百度。 API的数据安全传输前后端分离的开发方式，我们以接口为标准来进行推动，定义好接口，各自开发自己的功能，最后进行联调整合。无论是开发原生的APP还是webapp还是PC端的软件,只要是前后端分离的模式，就避免不了调用后端提供的接口来进行业务交互，这个时候，数据信息就非常重要了。 我们常用到的尽量保证数据安全的方法主要方式有：使用https、请求签名（防止参数被篡改）、身份确认机制（每次请求都要验证是否合法）、APP中使用ssl pinning防止抓包操作、对所有请求和响应都进行加解密操作等；这里我想说一下，可以了解一下jwt。 什么是JWT https://www.jianshu.com/p/576dbf44b2ae 分析URL的组成部分这个，主要采用PHP函数parse_url()来解析，本函数解析一个URL并返回一个关联数组，包含在URL中出现的各种组成部分，并了解URL的各个组成部分的含义和所在位置；一个URL，一般都包括：协议、域名、端口（web的很多80默认）、文件名、参数等。 有关parse_url的用法和返回值详见 http://www.php.net/manual/zh/function.parse-url.php 人事面试点 你之前所在公司的离职原因 谈谈你对加班的看法 你为什么会选择来我们公司 你未来的职业规划以及发展方向 对自己的一个评价 你的业余爱好，最近在看什么书 对你的经历提出一些问题 你还有什么问题要问我 你在之前，有去过那些公司面试？接下来还约了其他的面试吗 你的期望薪资以及要求 …… 最后这是我结合自己面试过程中，总结的一些经验，希望能帮助到大家，如果有说的不对或者不到位的地方，欢迎指正和交流。在此，祝愿大家都能找到一份满意的工作。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发必备之Git常用基础命令]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E4%B9%8BGit%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言这个Git常用命令的文章，之前在掘金和SegmentFault都有发不过，现在想整理到个人博客中，分享给大家，所以，才在这里重新发布。如有问题，请给我留言沟通，谢谢！ Git是什么？Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个免费、开源的版本控制软件，用于敏捷高效地处理任何或小或大的项目，可以有效、高速的处理从不同的项目版本管理。夸一下说：Git是目前世界上最先进的分布式版本控制系统（PS：Git不是GitHub哦）。 为什么要说Git命令行？在我们日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，掌握常用的一些命令，足够日常开发使用。 Git命令：# 首先，需要远程克隆一个项目 $ git clone [project-url] # 配置开发者的提交信息，包括用户名和邮箱 $ git config –global user.name [your-name] $ git config –global user.email [your-email] # 提交文件到版本控制，两个命令配合使用 $ git add [file-dir] $ git commit -m [comment] # 如果本地没有配置公钥，那么你是不是每次pull或者或者push等操作时，是不是都得需要输入Git账号密码？下面的这组命令，将能够快速的解决这个烦恼 $ git config –global credential.helper store # 拉取远程仓库的代码到本地工作区，一说到要拉取代码，很多人都会想到，git pull，但是我个人非常不喜欢这个命令，使用git fetch也可以，我如下两条命令拉取代码 $ git rempote update $git rebase origin:[branch-name] # 拉取代码，肯定会遇到有冲突的情况，这个时候，该怎么办呢？不要慌，有冲突就解决嘛，解决我就不说了，我就说，解决冲突代码后的操作，本地代码冲突解决完毕后，执行以下命令即可，即提交解决冲突文件到工作区，继续rebase $ git add [file-dir] $ git rebase –continue # 当然了，如果你拉取远程代码到本地遇到冲突了，你不想拉取了，想先退回到冲突前，该怎么办？执行下面的命令即可，即取消rebase $ git rebase –abort # 还有一个操作，也许偶尔能用得上，也就是，你rebase错了分支或者你rebase了对的分支，但是也想要会退到rebase之前，该怎么操作呢？下面这条命令很有用， $ git reset –hard ORIG_HEAD # 当然了，除了上面这条命令回退之外，下面的这条命令也可以，显示当前版本最近的几次提交，然后选择回退到某节点 $ git reflog [param] # 推送本地修改的代码到远程仓库，推送成功的前提是你本地的版本必须是最新的，即要与远程仓库的一直才会push成功，否则，请先拉取代码，再执行push操作 $ git push origin HEAD:[branch-name] 结束语如有说的不正确的地方，请指出，相互交流、学习。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现12306火车票自动抢票，并短信和邮件通知]]></title>
    <url>%2F2018%2F08%2F28%2FPython%E5%AE%9E%E7%8E%B012306%E7%81%AB%E8%BD%A6%E7%A5%A8%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8%EF%BC%8C%E5%B9%B6%E7%9F%AD%E4%BF%A1%E5%92%8C%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[前言这个脚本的文章，之前我有发布在掘金和SegmentFault上面过，现在想整理到个人博客中，分享给大家，所以，才在这里重新发布。如有问题，请给我留言沟通，谢谢！ 脚本实现及实践最近在学Python，所以用Python写了这个12306抢票脚本，分享出来，与大家共同交流和学习，有不对的地方，请大家多多指正。话不多说，进入正题： 这个脚本目前只能刷一趟车的，人数可以是多个，支持选取作为类型等。实现思路是splinter.browser模拟浏览器登陆和操作，由于12306的验证码不好自动识别，所以，验证码需要用户进行手动识别，并进行登陆操作，之后的事情，就交由脚本来操作就可以了，下面是我测试时候的一些截图： 第一步：如下图，首先输入抢票基本信息 第二步：然后进入登录页，需要手动输入验证码，并点击登陆操作 第三步：登陆后，自动进入到抢票页面，如下图这样的 最后：就是坐等刷票结果就好了，如下图这样，就说是刷票成功了，刷到票后，会进行短信和邮件的通知，请记得及时前往12306进行支付，不然就白抢了。 运行环境Python运行环境：python3.6用到的模块：re、splinter、time、sys、httplib2、urllib、smtplib、email未安装的模块，请使用pip instatll进行安装，例如：pip install splinter如下代码是这个脚本所有用到的模块引入： 12345678import refrom splinter.browser import Browserfrom time import sleepimport sysimport httplib2from urllib import parseimport smtplibfrom email.mime.text import MIMEText 准备城市名COOKIE刷票前信息准备，我主要说一下始发站和目的地的cookie值获取，因为输入城市的时候，需要通过cookie值，cookie值可以通过12306官网，然后在F12（相信所有的coder都知道这个吧）的network里面的查询请求cookie中可以看到，在请求的header里面可以找到，_jc_save_fromStation值是出发站的cookie，_jc_save_toStation的值是目的地的cookie，然后加入到代码里的城市的cookie字典city_list里即可，键是城市的首字母，值是cookie值的形式。 模拟登陆操作抢票，肯定需要先登录，我这里模拟的登录操作，会自动填充12306的账号名和密码，当然，你也可以在打开的浏览器中修改账号和密码，实现的关键代码如下： 123456789101112def do_login(self): """登录功能实现，手动识别验证码进行登录""" self.driver.visit(self.login_url) sleep(1) self.driver.fill('loginUserDTO.user_name', self.user_name) self.driver.fill('userDTO.password', self.password) print('请输入验证码……') while True: if self.driver.url != self.init_my_url: sleep(1) else: break 登录之后，就是控制刷票的各种操作处理了，这里，我就不贴代码了，因为代码比较多，别担心，在最后，我会贴出完整的代码的。 短信和邮件通知当刷票成功后，我会进行短信和邮件的双重通知，当然，这里短信通知的平台，就看你用那个具体来修改代码了，我用的是互亿无线的体验版的免费短信通知接口；发送邮件模块我用的是smtplib，发送邮件服务器用的是163邮箱，如果用163邮箱的话，你还没有设置客户端授权密码，记得先设置客户端授权密码就好了，挺方便的。以下是主要实现代码： 1234567891011121314151617181920212223242526272829303132333435def send_sms(self, mobile, sms_info): """发送手机通知短信，用的是-互亿无线-的测试短信""" host = "106.ihuyi.com" sms_send_uri = "/webservice/sms.php?method=Submit" account = "C59782899" pass_word = "19d4d9c0796532c7328e8b82e2812655" params = parse.urlencode( &#123;'account': account, 'password': pass_word, 'content': sms_info, 'mobile': mobile, 'format': 'json'&#125; ) headers = &#123;"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"&#125; conn = httplib2.HTTPConnectionWithTimeout(host, port=80, timeout=30) conn.request("POST", sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() conn.close() return response_strdef send_mail(self, receiver_address, content): """发送邮件通知""" # 连接邮箱服务器信息 host = 'smtp.163.com' port = 25 sender = 'xxxxxx@163.com' # 你的发件邮箱号码 pwd = '******' # 不是登陆密码，是客户端授权密码 # 发件信息 receiver = receiver_address body = '&lt;h2&gt;温馨提醒：&lt;/h2&gt;&lt;p&gt;' + content + '&lt;/p&gt;' msg = MIMEText(body, 'html', _charset="utf-8") msg['subject'] = '抢票成功通知！' msg['from'] = sender msg['to'] = receiver s = smtplib.SMTP(host, port) # 开始登陆邮箱，并发送邮件 s.login(sender, pwd) s.sendmail(sender, receiver, msg.as_string()) 源码分享说了那么多，感觉都是说了好多废话啊，哈哈，不好意思，耽误大家时间来看我瞎扯了，我贴上大家最关心的源码，请接码，大家在尝试运行过程中，有任何问题，可以给我留言或者私信我，我看到都会及时回复大家的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#!/usr/bin/env python# -*- coding: utf-8 -*-"""通过splinter刷12306火车票可以自动填充账号密码，同时，在登录时，也可以修改账号密码然后手动识别验证码，并登陆，接下来的事情，交由脚本来做了，静静的等待抢票结果就好（刷票过程中，浏览器不可关闭）author: cuizytime: 2018-05-30"""import refrom splinter.browser import Browserfrom time import sleepimport sysimport httplib2from urllib import parseimport smtplibfrom email.mime.text import MIMETextclass BrushTicket(object): """买票类及实现方法""" def __init__(self, user_name, password, passengers, from_time, from_station, to_station, number, seat_type, receiver_mobile, receiver_email): """定义实例属性，初始化""" # 1206账号密码 self.user_name = user_name self.password = password # 乘客姓名 self.passengers = passengers # 起始站和终点站 self.from_station = from_station self.to_station = to_station # 乘车日期 self.from_time = from_time # 车次编号 self.number = number.capitalize() # 座位类型所在td位置 if seat_type == '商务座特等座': seat_type_index = 1 seat_type_value = 9 elif seat_type == '一等座': seat_type_index = 2 seat_type_value = 'M' elif seat_type == '二等座': seat_type_index = 3 seat_type_value = 0 elif seat_type == '高级软卧': seat_type_index = 4 seat_type_value = 6 elif seat_type == '软卧': seat_type_index = 5 seat_type_value = 4 elif seat_type == '动卧': seat_type_index = 6 seat_type_value = 'F' elif seat_type == '硬卧': seat_type_index = 7 seat_type_value = 3 elif seat_type == '软座': seat_type_index = 8 seat_type_value = 2 elif seat_type == '硬座': seat_type_index = 9 seat_type_value = 1 elif seat_type == '无座': seat_type_index = 10 seat_type_value = 1 elif seat_type == '其他': seat_type_index = 11 seat_type_value = 1 else: seat_type_index = 7 seat_type_value = 3 self.seat_type_index = seat_type_index self.seat_type_value = seat_type_value # 通知信息 self.receiver_mobile = receiver_mobile self.receiver_email = receiver_email # 主要页面网址 self.login_url = 'https://kyfw.12306.cn/otn/login/init' self.init_my_url = 'https://kyfw.12306.cn/otn/index/initMy12306' self.ticket_url = 'https://kyfw.12306.cn/otn/leftTicket/init' # 浏览器驱动信息，驱动下载页：https://sites.google.com/a/chromium.org/chromedriver/downloads self.driver_name = 'chrome' self.executable_path = 'C:\\Users\cuizy\AppData\Local\Programs\Python\Python36\Scripts\chromedriver.exe' def do_login(self): """登录功能实现，手动识别验证码进行登录""" self.driver.visit(self.login_url) sleep(1) self.driver.fill('loginUserDTO.user_name', self.user_name) self.driver.fill('userDTO.password', self.password) print('请输入验证码……') while True: if self.driver.url != self.init_my_url: sleep(1) else: break def start_brush(self): """买票功能实现""" self.driver = Browser(driver_name=self.driver_name, executable_path=self.executable_path) # 浏览器窗口的大小 self.driver.driver.set_window_size(900, 700) self.do_login() self.driver.visit(self.ticket_url) try: print('开始刷票……') # 加载车票查询信息 self.driver.cookies.add(&#123;"_jc_save_fromStation": self.from_station&#125;) self.driver.cookies.add(&#123;"_jc_save_toStation": self.to_station&#125;) self.driver.cookies.add(&#123;"_jc_save_fromDate": self.from_time&#125;) self.driver.reload() count = 0 while self.driver.url.split('?')[0] == self.ticket_url: self.driver.find_by_text('查询').click() sleep(1) count += 1 print('第%d次点击查询……' % count) try: car_no_location = self.driver.find_by_id("queryLeftTable")[0].find_by_text(self.number)[1] current_tr = car_no_location.find_by_xpath("./../../../../..") if current_tr.find_by_tag('td')[self.seat_type_index].text == '--': print('无此座位类型出售，已结束当前刷票，请重新开启！') sys.exit(1) elif current_tr.find_by_tag('td')[self.seat_type_index].text == '无': print('无票，继续尝试……') else: # 有票，尝试预订 print('刷到票了（余票数：' + str(current_tr.find_by_tag('td')[self.seat_type_index].text) + '），开始尝试预订……') current_tr.find_by_css('td.no-br&gt;a')[0].click() sleep(1) key_value = 1 for p in self.passengers: # 选择用户 print('开始选择用户……') self.driver.find_by_text(p).last.click() # 选择座位类型 print('开始选择席别……') if self.seat_type_value != 0: seat_select = self.driver.find_by_id("seatType_" + str(key_value))[0] seat_select.find_by_xpath("//option[@value='" + str(self.seat_type_value) + "']")[0].click() key_value += 1 sleep(0.5) if p[-1] == ')': self.driver.find_by_id('dialog_xsertcj_ok').click() print('正在提交订单……') self.driver.find_by_id('submitOrder_id').click() sleep(2) # 查看放回结果是否正常 submit_false_info = self.driver.find_by_id('orderResultInfo_id')[0].text if submit_false_info != '': print(submit_false_info) self.driver.find_by_id('qr_closeTranforDialog_id').click() sleep(0.2) self.driver.find_by_id('preStep_id').click() sleep(0.3) continue print('正在确认订单……') self.driver.find_by_id('qr_submit_id').click() print('预订成功，请及时前往支付……') # 发送通知信息 self.send_mail(self.receiver_email, '恭喜您，抢到票了，请及时前往12306支付订单！') self.send_sms(self.receiver_mobile, '您的验证码是：8888。请不要把验证码泄露给其他人。') except Exception as error_info: print(error_info) except Exception as error_info: print(error_info) def send_sms(self, mobile, sms_info): """发送手机通知短信，用的是-互亿无线-的测试短信""" host = "106.ihuyi.com" sms_send_uri = "/webservice/sms.php?method=Submit" account = "C59782899" pass_word = "19d4d9c0796532c7328e8b82e2812655" params = parse.urlencode( &#123;'account': account, 'password': pass_word, 'content': sms_info, 'mobile': mobile, 'format': 'json'&#125; ) headers = &#123;"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"&#125; conn = httplib2.HTTPConnectionWithTimeout(host, port=80, timeout=30) conn.request("POST", sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() conn.close() return response_str def send_mail(self, receiver_address, content): """发送邮件通知""" # 连接邮箱服务器信息 host = 'smtp.163.com' port = 25 sender = 'gxcuizy@163.com' # 你的发件邮箱号码 pwd = 'CUIzy9118' # 不是登陆密码，是客户端授权密码 # 发件信息 receiver = receiver_address body = '&lt;h2&gt;温馨提醒：&lt;/h2&gt;&lt;p&gt;' + content + '&lt;/p&gt;' msg = MIMEText(body, 'html', _charset="utf-8") msg['subject'] = '抢票成功通知！' msg['from'] = sender msg['to'] = receiver s = smtplib.SMTP(host, port) # 开始登陆邮箱，并发送邮件 s.login(sender, pwd) s.sendmail(sender, receiver, msg.as_string())if __name__ == '__main__': # 12306用户名 user_name = input('请输入12306用户名：') while user_name == '': user_name = input('12306用户名不能为空，请重新输入：') # 12306登陆密码 password = input('请输入12306登陆密码：') while password == '': password = input('12306登陆密码不能为空，请重新输入：') # 乘客姓名 passengers_input = input('请输入乘车人姓名，多人用英文逗号“,”连接，（例如单人“张三”或者多人“张三,李四”）：') passengers = passengers_input.split(",") while passengers_input == '' or len(passengers) &gt; 4: print('乘车人最少1位，最多4位！') passengers_input = input('请重新输入乘车人姓名，多人用英文逗号“,”连接，（例如单人“张三”或者多人“张三,李四”）：') passengers = passengers_input.split(",") # 乘车日期 from_time = input('请输入乘车日期（例如“2018-08-08”）：') date_pattern = re.compile(r'^\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;$') while from_time == '' or re.findall(date_pattern, from_time) == []: from_time = input('乘车日期不能为空或者时间格式不正确，请重新输入：') # 城市cookie字典 city_list = &#123; 'bj': '%u5317%u4EAC%2CBJP', # 北京 'hd': '%u5929%u6D25%2CTJP', # 邯郸 'nn': '%u5357%u5B81%2CNNZ', # 南宁 'wh': '%u6B66%u6C49%2CWHN', # 武汉 'cs': '%u957F%u6C99%2CCSQ', # 长沙 'ty': '%u592A%u539F%2CTYV', # 太原 'yc': '%u8FD0%u57CE%2CYNV', # 运城 'gzn': '%u5E7F%u5DDE%u5357%2CIZQ', # 广州南 'wzn': '%u68A7%u5DDE%u5357%2CWBZ', # 梧州南 &#125; # 出发站 from_input = input('请输入出发站，只需要输入首字母就行（例如北京“bj”）：') while from_input not in city_list.keys(): from_input = input('出发站不能为空或不支持当前出发站（如有需要，请联系管理员！），请重新输入：') from_station = city_list[from_input] # 终点站 to_input = input('请输入终点站，只需要输入首字母就行（例如北京“bj”）：') while to_input not in city_list.keys(): to_input = input('终点站不能为空或不支持当前终点站（如有需要，请联系管理员！），请重新输入：') to_station = city_list[to_input] # 车次编号 number = input('请输入车次号（例如“G110”）：') while number == '': number = input('车次号不能为空，请重新输入：') # 座位类型 seat_type = input('请输入座位类型（例如“软卧”）：') while seat_type == '': seat_type = input('座位类型不能为空，请重新输入：') # 抢票成功，通知该手机号码 receiver_mobile = input('请预留一个手机号码，方便抢到票后进行通知（例如：18888888888）：') mobile_pattern = re.compile(r'^1&#123;1&#125;\d&#123;10&#125;$') while receiver_mobile == '' or re.findall(mobile_pattern, receiver_mobile) == []: receiver_mobile = input('预留手机号码不能为空或者格式不正确，请重新输入：') receiver_email = input('请预留一个邮箱，方便抢到票后进行通知（例如：test@163.com）：') while receiver_email == '': receiver_email = input('预留邮箱不能为空，请重新输入：') # 开始抢票 ticket = BrushTicket(user_name, password, passengers, from_time, from_station, to_station, number, seat_type, receiver_mobile, receiver_email) ticket.start_brush() 另外，该脚本，我也放到了GitHub上面，有兴趣的可以前往查看。源码地址：https://github.com/gxcuizy/Python/tree/master/12306qiangpiao]]></content>
      <tags>
        <tag>Python</tag>
        <tag>12306</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Python爬取国家统计局省市区三级地址库（支持MySQL和JSON格式）]]></title>
    <url>%2F2018%2F08%2F27%2F%E9%80%9A%E8%BF%87Python%E7%88%AC%E5%8F%96%E4%B8%89%E7%BA%A7%E5%9F%8E%E5%B8%82%E5%9C%B0%E5%9D%80%E5%BA%93%EF%BC%88%E6%94%AF%E6%8C%81MySQL%E5%92%8CJSON%E6%A0%BC%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据来源通过Python脚本，自动抓取国家统计局最新的中国省市区三级城市信息，目前抓取的最新数据为2017年统计用区划代码和城乡划分代码(截止2017年10月31日)，我会关注，时刻保持更新。 数据格式目前支持MySQL格式和JSON格式，其中MySQL的有两个版本，分别为三张表和一张表的，即三张表的为省市区三张表，而一张表的则把省市区三级城市通过关联关系都存在一张表中，可以根据自己的需求进行选择，如果有其他格式需求，可以联系我或者自己修改脚本。 脚本目录结构12345678├── json # 存储JSON数据格式├── mysql # 存储三张表的数据格式├── mysql_v2 # 存储一张表的数据格式├── city_to_json.py # 抓取JSON数据格式的脚本├── city_mysql.py # 抓取三张表的数据格式的脚本├── city_to_mysql_v2.py # 抓取一张表的数据格式的考平贝母├── mysql_init.sql # 存储三张表的数据的表结构├── mysql_v2_init # 存储一张表的数据的表结构 如有需要，直接下载后缀为json或者sql的文件即可直接使用，也可以根据对应的python脚本重新生成相应的省市区三级地址库数据。 抓取数据方法这里主要使用requests、beautifulsoup4以及json这三个模块，通过requests发送url页面请求，然后BeautifulSoup分析请求到的页面信息，抓取有效数据，通过json模块，读取以及存储json格式的数据，而mysql的数据则直接通过文件的读写操作即可。 源码分享这个爬虫脚本比较易读，而且碍于文章篇幅问题，所以，我这里就不贴源码了，直接放到交友网站GitHub上了，有兴趣的可以前往查看。 源码以及数据地址：https://github.com/gxcuizy/Python/tree/master/%E7%9C%81%E5%B8%82%E5%8C%BA%E4%B8%89%E7%BA%A7%E5%9C%B0%E5%9D%80%E5%BA%93]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python如何生成windows可执行的exe文件]]></title>
    <url>%2F2018%2F08%2F21%2FPython%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90windows%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84exe%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为什么要生成可执行文件 不需要安装对应的编程环境 可以将你的应用闭源 用户可以方便、快捷的直接使用 打包工具 pyinstaller 安装pyinstaller如果你的网络稳定，通常直接使用下面的命令安装即可：1pip install pyinstaller 当然了，你也可以下载pyinstaller源码包，然后进入包目录执行下面的命令，同样可以安装（前提是需要安装setuptools）：1python setup.py install 安装过程如下图所示 检查pyinstaller安装成功与否：只需要执行如下命令其中一个即可： 12pyinstaller --versionpyinstaller -v 如果出现如下界面，就说明是安装成功了 pyinstaller参数作用 -F 表示生成单个可执行文件 -D –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项） -w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧 -c –console, –nowindowed 使用控制台，无界面(默认) -p 表示你自己自定义需要加载的类路径，一般情况下用不到 -i 表示可执行文件的图标 其他参数，可以通过pyinstaller --help查看 开始打包进入python需要打包的脚本所在目录，然后执行下面的命令即可： 1python -F -i favicon.ico nhdz.py 执行过程如下图所示： 打包结果打包完成后，进入到当前目录下，会发现多了__pycache__、build、dist、nhdz.spec这四个文件夹或者文件，其中打包好的exe应用在dist目录下面，进入即可看到，可以把他拷贝到其他地方直接使用，如下图所示，是打包完成后的目录： 执行exe应用因为是exe应用，是可执行文件了，所以直接双击运行即可，运行效果如下图所示： 到这里，exe文件就已经生算是打包完成，并且可以运行了，如果你想在其他平台运行，只需要拷贝dist下面的文件即可 ICO图标制作前面需要用到ICO图标，大家可以网上搜索“ICO 在线生成”，可以直接点击ICO图标制作在上面制作、然后保存也行 最后大家有什么疑问或者想法，都可以直接和我交流，谢谢！]]></content>
      <tags>
        <tag>Python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新浪微博API生成短链接]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9AAPI%E7%94%9F%E6%88%90%E7%9F%AD%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[什么是短链接 短链接，通俗来说，就是将长的URL网址，通过程序计算等方式，转换为简短的网址字符串。 短链接服务国内各大微博都推出了自己的短链接服务。例如新浪微博、腾讯微博等。 为什么选用新浪微博API 新浪微博短链接API是开放的 新浪微博短链接API不需要用户登录 文档查询链接 short_url/shorten接口地址 网上的一些公开的AppKey 新浪微博短链接在线生成 使用方法拿到自己的AppKey后，替换类的成员属性$appKey的值即可，如下这样的，$shortUrl是API请求地址 1234// APPkey，我在网上找的（https://fengmk2.com/blog/appkey.html），可以自己申请protected $appKey = '569452181';// 转短连接API地址protected $shortUrl = 'https://api.weibo.com/2/short_url/shorten.json?'; 其他的，基本不需要配置，直接实例化类ShortLink，然后调用方法getShortUrl即可，需要说明的是长链接URL数组$longUrl里的值可以传多个值 当然了，为了方便，我写为一个类，可以根据自己的需要，进行调整，满足自己的需求即可。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php/** * 通过新浪微博API，生成短链接，支持一次性转多个长链接 * Class shortClass * @time 2018-08-14 * @author gxcuizy */Class ShortLink &#123; // APPkey，我在网上找的（https://fengmk2.com/blog/appkey.html），可以自己申请 protected $appKey = '569452181'; // 转短连接API地址 protected $shortUrl = 'https://api.weibo.com/2/short_url/shorten.json?'; /** * 生成短链接 * @param array $longUrl 长链接数组 * @return array 返回短连接数据 */ public function getShortUrl($longUrl = []) &#123; $code = true; $msg = '请求成功！'; $result = []; // 长链接数组为空，不处理 if (empty($longUrl)) &#123; $code = false; $msg = '长链接数据不能为空'; return ['code' =&gt; $code, 'msg' =&gt; $msg, 'result' =&gt; $result]; &#125; // 拼接请求URL $longUrlStr = $this-&gt;_getLongUrl($longUrl); $shortUrl = $this-&gt;shortUrl; $appKey = $this-&gt;appKey; $param = 'source=' . $appKey . '&amp;' . $longUrlStr; $curlUrl = $shortUrl . $param; // 发送CURL请求 $result = $this-&gt;_sendCurl($curlUrl); return ['code' =&gt; $code, 'msg' =&gt; $msg, 'result' =&gt; $result]; &#125; /** * 获取请求URL字符串 * @param array $longUrl 长链接数组 * @return string 长链接URL字符串 */ private function _getLongUrl($longUrl = []) &#123; $str = ''; foreach ($longUrl as $url) &#123; $str .= ('url_long=' . $url . '&amp;'); &#125; $newStr = substr($str, 0, strlen($str) - 1); return $newStr; &#125; /** * 发送CURL请求（GET） * @param string $curlUrl 请求地址 * @return array 返回信息 */ private function _sendCurl($curlUrl) &#123; // 初始化 $ch = curl_init(); // 设置选项，包括URL curl_setopt($ch, CURLOPT_URL, $curlUrl); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); // 执行并获取HTML文档内容 $output = curl_exec($ch); // 释放curl句柄 curl_close($ch); // Json数据转为数组 $result = json_decode($output, true); return $result; &#125;&#125;// 实例化对象$shortObj = new ShortLink();// 多个连接可以直接放到数组中，类似$longUrl = ['url1', 'url2', ……]$longUrl = ['http://blog.y0701.com/index.html'];// 开始转长链接为短链接$result = $shortObj-&gt;getShortUrl($longUrl);print_r($result); 结束语上面说到的网上查找得到的一些AppKey，因为来源不明，所以，不建议用于生产环境，需要用于生产环境的话，建议直接在新浪微博开发者平台里创建自己的应用就行。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法和入门]]></title>
    <url>%2F2018%2F08%2F10%2FMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[关于Markdown Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 谁创造了Markdown它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于前几年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：计算机程序员、企业家、作家、政治组织者和互联网黑客主义者；而百度百科则比较简单和含蓄，对他的介绍直接是：年少成名的计算机天才。老实说，他有着足以让你跪拜的人生经历。 为什么要使用Markdown 它基于纯文本，方便修改和共享 几乎可以在所有的文本编辑器中编写 跨平台使用 越来越多的网站支持Markdown 很容易转换为 HTML 文档或其他格式 摆脱Word（他的排版和阅读，要比Word体验好太多了） 适合用来编写文档、记录笔记、撰写文章 …… Markdown基础语法标题Markdown的标题，主要使用#，可表示1-6级标题，如下： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 段落与换行 段落的前后必须是空行，空行指的是行内什么都没有，或者只有空白符（空格或制表符） 如果需要在段落内换行，可以在前一行的末尾加入至少两个空格，然后换行继续写其它的内容 引用Markdown使用邮件风格的&gt;作为块引用。如果你熟悉邮件中的块引用，你也就知道如何在Markdown里创建一个块引用。在每一行前放一个 &gt; 最好 但是，Markdown允许你懒一些,尽在每个段落的开头放一个 &gt;，如下这样的：123&gt; 这是引用测试 这就是应用测试 这真的是引用测试 还可以嵌套引用，即在前一个引用的基础上再加一个 &gt; 即可，如下：123&gt; 这是引用测试 &gt;&gt; 这是嵌套引用测试&gt;&gt;&gt; 这是嵌套引用测试的嵌套 列表无序列表无序列表是使用.（点）、+（加号）、或-（减号）的符号来标记，需要注意的是标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行，例如：123- 这是无序列表- 这是无序列表- 这是无序列表 有序列表有序列表的标记方式是将上述的无序列表的符号换成数字，并辅以.（点）来标记，同时，提醒一下：数字的序列并不会影响生成的列表序列，无论你的序列是什么排的，结果仍然推荐按照自然顺序（1,2,3…）来编写，例如：1231. 这是有序列表2. 这是有序列表4. 这是有序列表 嵌套列表可以多层嵌套，标识符号不变，同上，需要说明的是无序列表和有序列表可以随意相互嵌套，同时，子列表前必须有相对于父列表两个以上空格的缩进，例如：12341. 有序列表 - 无序列表2. 有序列表 * 无序列表 代码代码块代码块可以使用三个 `（ ` 是Tab 键上边、数字1键左侧的那个按键）符号作为标识，即```，开头和结束都要，并且独占一行，例如： ```$str = ‘Hello World’;echo $str;``` 行内代码也可以通过 `来插入行内代码，建议使用一个`就行，例如： `echo ‘Hello World’` 分隔线可以在一行中使用三个或更多的 *（星）、-（减号） 或 _（下划线） 来添加一条分隔线，例如：12*************************************************# 上面是一条分割线 超链接超链接可以由两种形式生成：行内式和参考式 行内式行内式的写法如下：1[链接文字描述](实际超链接URL) 来个行内式的例子吧，如下： 1[博客地址](http://blog.y0701.com) 真实效果为： 博客地址 参考式参考式的写法如下： 1[链接文字描述][实际超链接锚点名] 继续来个参考式的例子吧，如下： 12[博客地址][blog_url] [blog_url]:http://blog.y0701.com 真实效果为： 博客地址 自动连接使用一对尖括号 &lt;&gt; 包括的 URL 或邮箱地址，即可被自动转换为超链接，例如： 1&lt;http://blog.y0701.com&gt; 上面的效果为： http://blog.y0701.com 图片插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个!（英文感叹号）。插入图片的方式也分为行内式和参考式两种 行内式行内式的用法和效果如下： 1![img](https://avatars3.githubusercontent.com/u/25812349?s=400&amp;v=4) 参考式行内式的用法和效果如下： 12![img][img_url] [img_url]:https://avatars3.githubusercontent.com/u/25812349?s=400&amp;v=4 强调 使用一对（一颗星） 或一对（一个下划线） _ _ 包括的文本来标识斜体，例如： 1这句话的 *斜体* 字都是 _斜体_ 的 效果为： 这句话的 斜体 字都是 _斜体_ 的 使用一对（两颗星） 或一对（两个下划线） 包括的文本来标识粗体，例如： 1这句话的 **粗体** 字都是 __粗体__ 的 效果为： 这句话的 粗体 字都是 粗体 的 使用一对（三颗星） 或一对（三个下划线） _ _ 包括的文本来标识斜体且加粗，例如： 1这句话的 ***粗斜体*** 字都是 ___粗斜体___ 的 效果为： 这句话的 粗体 字都是 _粗体_ 的 使用一对（两个波浪线） ~~ ~~ 包括的文本来标识删除，例如： 1这句话的 ~~删除~~ 字都是 ~~删除~~ 的 效果为： 这句话的 删除 字都是 删除 的 需要说明的是，用来包括文本的 或 _ 内侧不能有空白，否则 和 _ 将不会被正确的转换，具体的场景和效果，有兴趣的大家可以自己尝试 最后再说一遍：*、**、***、_、__、__\和~~都必须成对使用 字符转义反斜线（\）用于插入在Markdown语法中具有转义作用的字符，例如： 1这句话的 \*斜体\* 字不会是 \_斜体\_ 其效果为：这句话的 *斜体* 字不会是 _斜体_ Markdown完美支持Html的写法我们知道Markdown不支持指定图片的显示大小，只会按照百分百显示，那么这个时候，实在有必要的话，可以通过直接插入\&lt;img/>标签来指定相关属性，用法和效果如下： 1&lt;img src="https://avatars3.githubusercontent.com/u/25812349?s=400&amp;v=4" alt="这是头像" title="这是头像" width="50%" height="50%" /&gt; 其他HTML标签在Markdown里的用法和\&lt;img/>类似，就像在HTML在那样一模一样的用法即可 Markdown的扩展用法Markdown还有支持很多扩展的语法，这里就不说了，关于其它扩展语法可参见具体工具以及文档的相关使用说明即可 结束语这仅是一些Markdown的基础语法，如有说的不对的地方，欢迎大家指正，我会及时改正，谢谢。]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python通过跳板机连接远程MySQL]]></title>
    <url>%2F2018%2F08%2F10%2FPython%E9%80%9A%E8%BF%87%E8%B7%B3%E6%9D%BF%E6%9C%BA%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8BMySQL%2F</url>
    <content type="text"><![CDATA[工具直接跳板机连接远程MySQL数据库一般公司的数据库在一个远程服务器里，而这个服务器需要链接跳板机才可以访问，而通过远程桌面或云桌面才可以链接跳板机，说明访问数据库是需要一定的权限的（很多公司也不会让你通过本机就可以获取内部数据）这就有个问题了，也就是你不可能在本机直接去访问数据库，这个时候，就需要一些数据库管理工具，例如常用的Navicat、SQLyog等，都是可以的，下面是我Navicat的一些配置（打码部分为配置信息）： SSH连接配置信息 MySQL连接属性常规信息 Python连接安装sshtunnelPython连接的话，得借助sshtunnel模块，这个模块是第三方的模块，所以得先安装，安装方式如下，直接命令行安装就行。 1pip insall sshtunnel 基本配置说明1234567891011121314151617# 跳板机SSH连接with SSHTunnelForwarder( ('192.168.0.1', 22), ssh_username="test", ssh_pkey="test.pem", remote_bind_address=('*************mysql.rds.aliyuncs.com', 3306)) as tunnel: # 数据库连接配置，host默认127.0.0.1不用修改 conn = pymysql.connect( host='127.0.0.1', port=tunnel.local_bind_port, user='root', password='root', db='test', charset='utf8', cursorclass=pymysql.cursors.DictCursor ) 从上面代码可以看到，跳板机的SSH配置信息，192.168.0.1为服务器IP地址，ssh_username为用户名，ssh_pkey为本机私钥存放位置，remote_bind_address为跳板机地址，user为mysql连接用户名，passport为密码，db就是连接的数据库名了，其他的不用配置了，发现连接不对的，就再核对一些配置信息，连接完毕，一定记得关闭连接。 完整源码分享123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-"""通过跳板机，连接远程mysql数据库author: gxcuizytime: 2018-08-10"""import pymysqlfrom sshtunnel import SSHTunnelForwarder# 程序主入口if __name__ == "__main__": # 跳板机SSH连接 with SSHTunnelForwarder( ('192.168.0.1', 22), ssh_username="test", ssh_pkey="test.pem", remote_bind_address=('*************mysql.rds.aliyuncs.com', 3306) ) as tunnel: # 数据库连接配置，host默认127.0.0.1不用修改 conn = pymysql.connect( host='127.0.0.1', port=tunnel.local_bind_port, user='root', password='root', db='test', charset='utf8', cursorclass=pymysql.cursors.DictCursor ) # 获取游标 cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) # 查询数据库，查询一条数据，其他CURD操作类似 sql = "SELECT name FROM table_name WHERE id = '%s'" prams = ('1',) cursor.execute(sql % prams) info = cursor.fetchone() print(info) # 关闭连接 cursor.close() conn.close() 结束语Python可以做很多事情，大家有兴趣的话，可以一起研究和讨论，如有疑问，可以留言或者直接联系我，谢谢。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python下载网易云歌曲（版权限制的怎么播放和下载呢？）]]></title>
    <url>%2F2018%2F08%2F08%2FPython%E4%B8%8B%E8%BD%BD%E7%BD%91%E6%98%93%E4%BA%91%E6%AD%8C%E6%9B%B2%EF%BC%88%E7%89%88%E6%9D%83%E9%99%90%E5%88%B6%E7%9A%84%E6%80%8E%E4%B9%88%E6%92%AD%E6%94%BE%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%91%A2%EF%BC%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[为什么要这样下载网易云音乐，我相信大多数人都用过，我个人觉得非常好用，也一直在用，有的时候，我们搜索一些网易歌曲，发现播放不了，甚至下载不了，因为提示“版权方要求，当前歌曲仅限开通音乐包使用”（见下图），也就是，需要购买才能够下载以及播放，有没有办法不花钱就能播放和下载这首歌曲呢？我研究了一下，还没发现呢，哈哈哈哈，往下看，你会发现惊喜的…… 怎么查找版权限制不让下载和播放的音乐初探network请求信息首先，我想到的是打开F12，查看所有的network请求，一个一个的查看请求返回信息，突然发现了惊喜，如下图所示： 那个请求返回的url，我想应该就是音乐的URL源地址，但是，我通过Python脚本下载这个音乐下来后发现，和我想象的有点不一样，因为这个url确实是音乐的源地址，但是并不是我需要的，因为这个url是当前播放音乐的源地址，然后，我继续点击其他按钮，当我点击播放音乐按钮的时候，有一个detail的请求，里面返回了很多信息，如下图所示： 深入查看network请求信息我研究了一下这些返回信息，发现并没有找到需要的音乐url源地址，然后只能继续在network里面找，刚开始，我只是找的XHR的请求，然后我想着，查找All的请求试试，因为，All请求里，可以包含所有的资源请求，包括图片以及文件资源等，也许会有惊喜，果然，不出所料，让我找到了一个好东西，如下图这样的： 发现惊喜因为通过前面拿到当前播放的音乐的url源地址，猜想着所有的音乐的url应该都包含着mp3的后缀，所以，我就Ctrl+F，进行mp3的搜索，果然，看到包含mp3的请求就那几个，然后逐一分析，发现，有一个请求信息，也就是上图中的第一个请求，是一个MP3文件资源，所以，我猜想，这个应该就是我需要的音乐URL了吧，然后我拿到这个URL继续去下载文件资源，果然，这就是我需要的音乐URL源地址，到这里，也就是找到了这个因为版权受限不让播放和下载的音乐了，惊不惊喜？意不意外？ Python下载MP3文件源码最后，分享一波Python下载MP3资源的源码，使用的时候，得先进行几个配置，首先是url，url就是需要下载的音乐URL地址，folder就是音乐需要保存的位置，话不多说，直接上源码 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-"""下载MP3文件author: gxcuizytime：2018-08-08"""import requestsimport osdef download_file(mp3_url, file_folder): """下载MP3文件""" # 文件夹不存在，则创建文件夹 folder = os.path.exists(file_folder) if not folder: os.makedirs(file_folder) # 读取远程MP3资源 res = requests.get(mp3_url) res.raise_for_status() # 获取文件名 file_name = os.path.basename(mp3_url) file_path = os.path.join(file_folder, file_name) print('正在写入资源文件：', file_path) # 保存到本地 image_file = open(file_path, 'wb') for chunk in res.iter_content(100000): image_file.write(chunk) image_file.close() print('写入文件结束！')# 程序主入口if __name__ == "__main__": # MP3源地址url url = 'http://m10.music.126.net/20180808172234/4446d41c850238c25cdcff1fe43249a4/ymusic/3686/b5b4/961c/39c9a20e7db813ea3290e1b1580cfa70.mp3' # MP3保存文件夹 folder = 'mp3/' # 调用下载方法 download_file(url, folder) 结束语大家有什么不理解或者不明白的的，可以联系我，或者给我留言，我会及时回复的，欢迎沟通和交流，谢谢。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python通过paramiko从远处服务器下载文件资源到本地]]></title>
    <url>%2F2018%2F08%2F02%2FPython%E9%80%9A%E8%BF%87paramiko%E4%BB%8E%E8%BF%9C%E5%A4%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[为什么要用Python脚本下载以及基本介绍经常会有人需要从远程服务器下载一些文件资源，下载个别小文件可以直接用sz等命令，但是，需要下载一个文件夹呢？sz就不行了，这时候当然可以先压缩文件夹，然后下载，这样也是可以的，只要文件不是很大，那么，有没有其他办法下载文件夹呢？办法当然是有的，就是写Python脚本，然后通过paramiko模块就可以从远程传输下载文件夹到本地了，是不是很方便呢…… paramiko模块提供了ssh及sftp进行远程登录服务器执行命令和上传下载文件的功能。这是一个第三方的软件包，使用之前需要先进行安装，我们这里主要利用sftp进行下载传输文件 就像下图中的运行，可以一个一个的循环下载文件 使用时候的基本配置下面的这些信息需要自己配置一下，即初始化一些参数，包括服务器信息以及远程文件和本地文件的存放路径配置 123456789# 服务器连接信息host_name = '172.0.0.1'user_name = 'root'password = 'root'port = 22# 远程文件路径（需要绝对路径）remote_dir = '/data/nfs/zdlh/pdf/2018/07/31'# 本地文件存放路径（绝对路径或者相对路径都可以）local_dir = 'file_download/' 实现源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-"""通过paramiko从远处服务器下载文件资源到本地author: gxcuizytime: 2018-08-01"""import paramikoimport osfrom stat import S_ISDIR as isdirdef down_from_remote(sftp_obj, remote_dir_name, local_dir_name): """远程下载文件""" remote_file = sftp_obj.stat(remote_dir_name) if isdir(remote_file.st_mode): # 文件夹，不能直接下载，需要继续循环 check_local_dir(local_dir_name) print('开始下载文件夹：' + remote_dir_name) for remote_file_name in sftp.listdir(remote_dir_name): sub_remote = os.path.join(remote_dir_name, remote_file_name) sub_remote = sub_remote.replace('\\', '/') sub_local = os.path.join(local_dir_name, remote_file_name) sub_local = sub_local.replace('\\', '/') down_from_remote(sftp_obj, sub_remote, sub_local) else: # 文件，直接下载 print('开始下载文件：' + remote_dir_name) sftp.get(remote_dir_name, local_dir_name)def check_local_dir(local_dir_name): """本地文件夹是否存在，不存在则创建""" if not os.path.exists(local_dir_name): os.makedirs(local_dir_name)if __name__ == "__main__": """程序主入口""" # 服务器连接信息 host_name = '172.17.2.18' user_name = 'dev' password = 'dev@zdlh' port = 22 # 远程文件路径（需要绝对路径） remote_dir = '/data/nfs/zdlh/pdf/2018/07/31' # 本地文件存放路径（绝对路径或者相对路径都可以） local_dir = 'file_download/' # 连接远程服务器 t = paramiko.Transport((host_name, port)) t.connect(username=user_name, password=password) sftp = paramiko.SFTPClient.from_transport(t) # 远程文件开始下载 down_from_remote(sftp, remote_dir, local_dir) # 关闭连接 t.close() 结束语在Python中，可以很好地利用Parmmiko的sftp完成文件传输操作。大家有什么疑问或者想法，可以留言或者联系我。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包工具推荐：Fiddler、Charles]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%EF%BC%9AFiddler%E3%80%81Charles%2F</url>
    <content type="text"><![CDATA[1、抓包工具FilddlerFiddler是最强大最好用的Web调试工具之一,它能记录所有客户端和服务器的http和https请求,允许你监视,设置断点,甚至修改输入输出数据,Fidder包含了一个强大的基于事件脚本的子系统,并且能使用.net语言进行扩展 下载地址 https://www.telerik.com/download/fiddler 安装使用教程 https://www.cnblogs.com/R-bear/p/7508133.html 2、抓包工具CharlesCharles是常用的截取网络封包的工具(俗称抓包)。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 下载地址 https://www.charlesproxy.com/download 安装使用教程 https://zhubangbang.com/charlesproxy]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP推荐编码规范]]></title>
    <url>%2F2018%2F07%2F26%2FPHP%E6%8E%A8%E8%8D%90%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[我们为什么需要编码规范？ 为了提高工作效率，保证开发的有效性和合理性 为了提高代码可读性和可重复利用性，从而节约沟通成本 1. 排版 程序块要采用缩进风格编写，缩进的格式建议为4个空格，单模块内必须统一 关键字与其后的左括号之间有一个空格，而函数名与左括号之间不应有任何字符包括空格 if / while等逻辑结构体，即使只有一行，也必须加上花括号包含，不建议写成一行，增加可读性 同一个代码块的变量定义， 应该尽可能集中在块开始位置，提高可读性 2. 命令 常量命名必须全部大写字母，单词之间以下划线’_’连接 关键字true、false、null必须小写 类的命名采用驼峰法（首字母大写） 类的方法命名采用驼峰命名（首字母小写） 普通函数的命名采用过程函数风格命名，即使用小写字母和下划线（小写字母开头）的方式 类成员变量和局部变量必须采用驼峰命名法（首字母小写） 以单下划线“_”打头的函数或方法作为私有方法 以双下划线“__”打头的函数或方法作为魔术方法 3. 注释 建议文件、函数、类以及成员变量都应包含注释，关键代码必须有注释 单行注释用//，不能使用#作为单行注释， 多行注释\/* **\/不能出现在同一行 方法或者函数必须通过param和return标记指明其参数和返回值 4. 编码原则 生成对象时，必须使用new ClassName()，不要用new ClassName 除非特殊情况，否则不允许使用require和include，而使用对应的require_once/include_once 能用foreach的就不要用for，能用for的就不要用while 字符串尽量用’ ‘而不是” “进行引用，一个是效率问题，一个是安全问题 函数允许使用默认参数，但是默认参数需要放到参数列表最后面 禁止使用and、or， 而是使用&amp;&amp;、|| $i, $j这样无意义的变量名，除非是用作循环计数变量 5. 数据表和字段 数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头 不建议使用驼峰和中文作为数据表字段命名 6. 代码性能 把重复调用放在循环体外 不要在你的提交的代码中包含调试代码，就算是注释掉了也不行 运行代码时不应该出现任何错误信息，并不是把警告和提示信息关掉来满足这一点 最后最后说的是，规范也不是死的或者强制的，只是一种编码建议，更加不是标准。“约定大于规范”，如果有的规范太死板，不适应您的团队，您可以不采用，按照您自己的规范即可。当然了，你有任何问题，都可以与我交流和联系。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog,that is my first article. Quick StartCreate a new post1$ hexo new "My New Post" Run server1$ hexo server Generate static files1$ hexo generate Deploy to remote sites1$ hexo deploy]]></content>
  </entry>
</search>
